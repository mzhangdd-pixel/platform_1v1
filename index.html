<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒäººå¹³å°ä¹±æ–— (Dual Gamepad V6 - Final)</title>
    <style>
        :root {
            --apple-blue: #0071e3;
            --apple-text: #1d1d1f;
            --apple-gray: #86868b;
            --apple-bg: #fbfbfd;
            --apple-card-bg: #ffffff;
            --apple-border: #d2d2d7;
            --apple-modal-bg: rgba(255, 255, 255, 0.8);
        }

        body.dark-mode {
            --apple-text: #f5f5f7;
            --apple-gray: #a1a1a6;
            --apple-bg: #000000;
            --apple-card-bg: #1c1c1e;
            --apple-border: #38383a;
            --apple-modal-bg: rgba(30, 30, 30, 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--apple-bg);
            color: var(--apple-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.5s, color 0.5s;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            border-radius: 18px;
            overflow: hidden;
            background: var(--apple-card-bg);
            transition: background-color 0.5s;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .player-hud {
            width: 300px;
            padding: 10px;
            color: var(--apple-text);
        }

        .bar-container {
            width: 100%;
            height: 8px;
            background: rgba(128,128,128,0.2);
            margin-top: 8px;
            position: relative;
            border-radius: 4px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.1s linear;
            border-radius: 4px;
        }

        .hp-fill { background-color: #ff3b30; }
        .resource-fill { background-color: #007aff; }

        .cd-icons {
            display: flex;
            margin-top: 10px;
            gap: 8px;
        }

        .cd-box {
            width: 32px;
            height: 32px;
            background: rgba(128,128,128,0.1);
            border: 1px solid var(--apple-border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--apple-text);
            position: relative;
            overflow: hidden;
        }

        .cd-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            transition: height 0.1s;
        }

        /* Apple Style Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--apple-modal-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
            transition: opacity 0.5s;
        }

        #start-screen h1 {
            font-size: 48px;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 10px;
            color: var(--apple-text);
        }

        #start-screen p {
            font-size: 17px;
            color: var(--apple-gray);
            margin-bottom: 40px;
        }

        .char-select-container {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap; /* Allow wrapping for more chars */
            justify-content: center;
            max-width: 800px;
        }

        .char-card {
            width: 100px; /* Slightly smaller to fit more */
            height: 160px;
            border: 1px solid var(--apple-border);
            border-radius: 18px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            background: var(--apple-card-bg);
            text-align: center;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.04);
            color: var(--apple-text);
            position: relative; 
        }

        .char-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.15);
            border-color: var(--apple-gray);
        }

        .char-icon { font-size: 36px; margin-bottom: 10px; }
        
        .char-card h3 { 
            margin: 5px 0; 
            font-size: 14px; 
            font-weight: 600; 
            color: var(--apple-text) !important; 
        }

        .char-desc {
            font-size: 10px;
            color: var(--apple-gray);
            margin-top: 5px;
            line-height: 1.2;
        }

        /* Selection States */
        .char-card.selected-p1 { border: 2px solid #ff3b30; background-color: rgba(255, 59, 48, 0.1); }
        .char-card.selected-p2 { border: 2px solid #007aff; background-color: rgba(0, 122, 255, 0.1); }
        .char-card.selected-both { border: 2px solid #af52de; background-color: rgba(175, 82, 222, 0.1); }

        /* New Gamepad Cursor Indicators */
        .p1-cursor-indicator, .p2-cursor-indicator {
            position: absolute; top: -15px; left: 50%; transform: translateX(-50%);
            font-size: 24px; display: none; animation: bounce 1s infinite;
        }
        .char-card.hover-p1 .p1-cursor-indicator { display: block; content: "ğŸ”»"; color: #ff3b30; }
        .char-card.hover-p2 .p2-cursor-indicator { display: block; content: "ğŸ”»"; color: #007aff; }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, 0); }
            50% { transform: translate(-50%, -5px); }
        }

        button.btn-primary {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 17px;
            font-weight: 500;
            cursor: pointer;
            background-color: var(--apple-blue);
            color: white;
            border: none;
            border-radius: 980px;
            transition: background-color 0.2s;
        }

        button.btn-primary:hover { background-color: #0077ED; }

        .instructions { 
            font-size: 13px; 
            color: var(--apple-gray); 
            margin-top: 40px; 
            text-align: center;
            background: rgba(128,128,128,0.05);
            padding: 20px;
            border-radius: 12px;
        }
        
        .instructions table th { color: var(--apple-text); font-weight: 600; }
        
        #p1-name { color: #ff3b30 !important; font-size: 16px; }
        #p2-name { color: #007aff !important; font-size: 16px; }
        
        #center-hud {
            text-align:center; 
            margin-top:10px; 
            font-size: 28px; 
            font-weight: 800; 
            color: var(--apple-text);
        }
        #game-timer {
            font-size: 14px; 
            color: var(--apple-gray); 
            font-weight: 400;
            margin-top: 5px;
            font-variant-numeric: tabular-nums;
        }

        #gamepad-status {
            position: absolute;
            top: 10px;
            left: 20px;
            font-size: 12px;
            color: var(--apple-gray);
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #gamepad-status.active { opacity: 1; }
        .gp-icon { width: 18px; height: 12px; background: #86868b; border-radius: 2px; }

        /* Settings Modal */
        #settings-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
            z-index: 20;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        /* Pairing Modal Style */
        #pairing-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            z-index: 30; display: none; align-items: center; justify-content: center;
        }

        .settings-card {
            width: 400px;
            background: var(--apple-card-bg);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            text-align: center;
        }
        .settings-card h2 { margin-top: 0; margin-bottom: 20px; color: var(--apple-text); }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--apple-border);
            font-size: 15px;
        }
        .setting-row:last-of-type { border-bottom: none; }
        
        /* Apple Switch Toggle */
        .switch { position: relative; display: inline-block; width: 40px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute; content: "";
            height: 20px; width: 20px;
            left: 2px; bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input:checked + .slider { background-color: var(--apple-blue); }
        input:checked + .slider:before { transform: translateX(16px); }

        .close-btn {
            margin-top: 20px;
            background: #e5e5ea;
            color: #1d1d1f;
            width: 100%;
        }
        .close-btn:hover { background: #d1d1d6; }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="700"></canvas>
    
    <div id="ui-layer">
        <div id="gamepad-status"><div class="gp-icon"></div> P1: Off | P2: Off</div>

        <div class="player-hud" id="p1-hud">
            <div id="p1-name">P1: æœªé€‰æ‹©</div>
            <div style="font-size:13px; color:#86868b; margin-top:4px;">ç”Ÿå‘½: <span id="p1-lives" style="font-weight:600">3</span> | è¡€é‡: <span id="p1-hp-text" style="font-weight:600">0</span></div>
            <div class="bar-container"><div id="p1-hp-bar" class="bar-fill hp-fill" style="width: 100%;"></div></div>
            <div class="bar-container"><div id="p1-res-bar" class="bar-fill resource-fill" style="width: 100%;"></div></div>
            <div class="cd-icons">
                <div class="cd-box">X<div id="p1-cd-atk" class="cd-overlay" style="height:0%"></div></div>
                <div class="cd-box">C<div id="p1-cd-skill" class="cd-overlay" style="height:0%"></div></div>
                <div class="cd-box">V<div id="p1-cd-ult" class="cd-overlay" style="height:0%"></div></div>
                <div class="cd-box">F<div id="p1-cd-swap" class="cd-overlay" style="height:0%"></div></div>
            </div>
        </div>
        
        <div id="center-hud">
            VS
            <div id="game-timer">00:00</div>
        </div>

        <div class="player-hud" id="p2-hud" style="text-align: right;">
            <div id="p2-name">P2: æœªé€‰æ‹©</div>
            <div style="font-size:13px; color:#86868b; margin-top:4px;">è¡€é‡: <span id="p2-hp-text" style="font-weight:600">0</span> | ç”Ÿå‘½: <span id="p2-lives" style="font-weight:600">3</span></div>
            <div class="bar-container"><div id="p2-hp-bar" class="bar-fill hp-fill" style="width: 100%; float:right;"></div></div>
            <div class="bar-container"><div id="p2-res-bar" class="bar-fill resource-fill" style="width: 100%; float:right;"></div></div>
            <div class="cd-icons" style="justify-content: flex-end;">
                <div class="cd-box">,<div id="p2-cd-atk" class="cd-overlay" style="height:0%"></div></div>
                <div class="cd-box">.<div id="p2-cd-skill" class="cd-overlay" style="height:0%"></div></div>
                <div class="cd-box">/<div id="p2-cd-ult" class="cd-overlay" style="height:0%"></div></div>
                <div class="cd-box">;<div id="p2-cd-swap" class="cd-overlay" style="height:0%"></div></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>Choose Your Fighter</h1>
        <p>P1 (Left Click) &nbsp;|&nbsp; P2 (Right Click)</p>
        <div class="char-select-container" id="char-selection">
            <!-- JS will populate this -->
        </div>
        <button id="start-btn" class="btn-primary" style="display:none;">å¼€å§‹å¯¹æˆ˜</button>
        <div class="instructions">
            <p style="margin-bottom: 10px; font-weight:600; color:var(--apple-text);">æŒ‰ <span style="background:#eee; padding:2px 5px; border-radius:4px; color:#000;">ESC</span> æ‰“å¼€æ¸¸æˆè®¾ç½®</p>
            <table style="margin:0 auto; font-size:12px; text-align:left; border-spacing: 15px 5px;">
                <tr><th>åŠ¨ä½œ</th><th style="color:#ff3b30">P1 (Key/Pad)</th><th style="color:#007aff">P2 (Key/Pad)</th></tr>
                <tr><td>ç§»åŠ¨</td><td>WASD / <span style="color:#0071e3">å·¦æ‘‡æ†</span></td><td>I J K L / <span style="color:#0071e3">å·¦æ‘‡æ†</span></td></tr>
                <tr><td>è·³è·ƒ</td><td>W / Bé”®</td><td>I / Bé”®</td></tr>
                <tr><td>æ”»å‡»</td><td>X / <span style="color:#0071e3">ZRé”®</span> (æ³•å¸ˆå¯è“„åŠ›)</td><td>, / <span style="color:#0071e3">ZRé”®</span></td></tr>
                <tr><td>æŠ€èƒ½</td><td>C / <span style="color:#0071e3">Aé”®</span></td><td>. / <span style="color:#0071e3">Aé”®</span></td></tr>
                <tr><td>å¤§æ‹›</td><td>V / Xé”®</td><td>/ / Xé”®</td></tr>
                <tr><td>æ¢ä½</td><td>F / ZLé”®</td><td>; / ZLé”®</td></tr>
            </table>
        </div>
    </div>

    <!-- NEW: Gamepad Pairing Modal -->
    <div id="pairing-modal" style="display:none;">
        <div class="settings-card">
            <h2 id="pair-title">ğŸ® æ‰‹æŸ„é…å¯¹</h2>
            <div id="pair-step-indicator" style="margin-bottom:20px; color:var(--apple-blue); font-weight:600; font-size:18px;">
                ç­‰å¾… P1 é…å¯¹...
            </div>
            <p style="color:var(--apple-gray); margin-bottom:30px; line-height:1.5;">
                è¯· <span id="target-player" style="color:var(--apple-text); font-weight:bold;">P1</span> ç©å®¶<br>
                åŒæ—¶æŒ‰ä½æ‰‹æŸ„èƒŒéƒ¨çš„ <span style="background:#eee; padding:2px 6px; border-radius:4px; color:#000;">ZL</span> + <span style="background:#eee; padding:2px 6px; border-radius:4px; color:#000;">ZR</span> é”®
            </p>
            <div id="connected-list" style="margin-bottom:20px; font-size:13px; color:var(--apple-gray);">
                å·²è¿æ¥: æ— 
            </div>
            <button class="btn-primary close-btn" onclick="closePairing()">å®Œæˆ / è·³è¿‡</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="settings-card">
            <h2>æ¸¸æˆè®¾ç½®</h2>
            
            <div class="setting-row">
                <span>æ‰‹æŸ„è®¾ç½® (åŒäººæ”¯æŒ)</span>
                <button class="btn-primary" style="padding: 5px 15px; font-size: 14px; margin-top:0;" onclick="openPairing()">
                    âš™ï¸ é…ç½®/é“¾æ¥æ‰‹æŸ„
                </button>
            </div>

            <div class="setting-row">
                <span>æ— å†·å´æ¨¡å¼ (æ— é™ç«åŠ›)</span>
                <label class="switch">
                    <input type="checkbox" id="set-cd">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="setting-row">
                <span>å¤œé—´æ¨¡å¼</span>
                <label class="switch">
                    <input type="checkbox" id="set-night">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="setting-row">
                <span>æè‡´åä¸½ç‰¹æ•ˆ (è€—èƒ½)</span>
                <label class="switch">
                    <input type="checkbox" id="set-flashy">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="setting-row">
                <span>æ¸¸æˆéŸ³æ•ˆ</span>
                <label class="switch">
                    <input type="checkbox" id="set-audio">
                    <span class="slider"></span>
                </label>
            </div>

            <button class="btn-primary close-btn" onclick="toggleSettings()">å…³é—­</button>
        </div>
    </div>
</div>

<script>
/** * -----------------------------------------------------
 * 1. Sound Manager (AudioContext API)
 * -----------------------------------------------------
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.enabled = false;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    play(type, pitchMod = 1.0) {
        if (!this.enabled || !this.ctx) return;
        this.init();

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        const now = this.ctx.currentTime;

        switch (type) {
            case 'ui':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'jump':
                osc.type = 'square';
                osc.frequency.setValueAtTime(150 * pitchMod, now);
                osc.frequency.exponentialRampToValueAtTime(300 * pitchMod, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'attack':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200 * pitchMod, now);
                osc.frequency.exponentialRampToValueAtTime(50 * pitchMod, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'skill':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400 * pitchMod, now);
                osc.frequency.linearRampToValueAtTime(600 * pitchMod, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
                break;
            case 'ult':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(800, now + 1.0);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 1.5);
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 20;
                lfo.connect(gain.gain);
                lfo.start(now);
                lfo.stop(now + 1.5);
                osc.start(now);
                osc.stop(now + 1.5);
                break;
            case 'hit':
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
        }
    }
}
const soundManager = new SoundManager();

/** * -----------------------------------------------------
 * 2. Settings Management
 * -----------------------------------------------------
 */
const Settings = {
    noCooldown: false,
    nightMode: false,
    flashyMode: false,
    audioEnabled: false,

    load() {
        const saved = localStorage.getItem('brawl_settings');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.noCooldown = parsed.noCooldown || false;
            this.nightMode = parsed.nightMode || false;
            this.flashyMode = parsed.flashyMode || false;
            this.audioEnabled = parsed.audioEnabled || false;
        }
        this.apply();
    },

    save() {
        localStorage.setItem('brawl_settings', JSON.stringify({
            noCooldown: this.noCooldown,
            nightMode: this.nightMode,
            flashyMode: this.flashyMode,
            audioEnabled: this.audioEnabled
        }));
    },

    apply() {
        document.getElementById('set-cd').checked = this.noCooldown;
        document.getElementById('set-night').checked = this.nightMode;
        document.getElementById('set-flashy').checked = this.flashyMode;
        document.getElementById('set-audio').checked = this.audioEnabled;

        document.body.classList.toggle('dark-mode', this.nightMode);
        soundManager.enabled = this.audioEnabled;
    }
};

document.getElementById('set-cd').addEventListener('change', e => { Settings.noCooldown = e.target.checked; Settings.save(); Settings.apply(); });
document.getElementById('set-night').addEventListener('change', e => { Settings.nightMode = e.target.checked; Settings.save(); Settings.apply(); });
document.getElementById('set-flashy').addEventListener('change', e => { Settings.flashyMode = e.target.checked; Settings.save(); Settings.apply(); });
document.getElementById('set-audio').addEventListener('change', e => { Settings.audioEnabled = e.target.checked; Settings.save(); Settings.apply(); });

function toggleSettings() {
    const modal = document.getElementById('settings-modal');
    const isHidden = modal.style.display === 'none' || modal.style.display === '';
    modal.style.display = isHidden ? 'flex' : 'none';
    if (isHidden) {
        Settings.load(); 
        if(gameState === 'playing') gameState = 'paused';
    } else {
        if(gameState === 'paused') gameState = 'playing';
    }
}

window.addEventListener('keydown', e => {
    if (e.key === 'Escape') toggleSettings();
});


/** * -----------------------------------------------------
 * REFACTORED: Dual Channel Gamepad Handler
 * -----------------------------------------------------
 */
class GamepadHandler {
    constructor() {
        this.controllers = { p1: null, p2: null }; // Store Gamepad Indices
        this.deadzone = 0.15;
        this.active = true;
        
        // Menu Navigation State
        this.menuCooldown = { p1: 0, p2: 0 };
        this.isPairingMode = false;
        this.pairingStep = 1; // 1 for P1, 2 for P2
        
        window.addEventListener("gamepadconnected", (e) => this.onConnect(e));
        window.addEventListener("gamepaddisconnected", (e) => this.onDisconnect(e));
    }

    onConnect(e) {
        createPopup(CANVAS_W/2, 50, `ğŸ® Gamepad ${e.gamepad.index} Detected`, "#0071e3");
        // Auto-assign if empty (Optional, but manual pairing is safer)
        if (this.controllers.p1 === null) this.controllers.p1 = e.gamepad.index;
        else if (this.controllers.p2 === null) this.controllers.p2 = e.gamepad.index;
        this.updateStatusUI();
    }

    onDisconnect(e) {
        if (this.controllers.p1 === e.gamepad.index) this.controllers.p1 = null;
        if (this.controllers.p2 === e.gamepad.index) this.controllers.p2 = null;
        createPopup(CANVAS_W/2, 50, `ğŸš« Gamepad Disconnected`, "#ff3b30");
        this.updateStatusUI();
    }

    startPairing() {
        this.isPairingMode = true;
        this.pairingStep = 1;
        this.controllers = { p1: null, p2: null }; // Reset on re-pair
        this.updatePairingUI();
    }

    stopPairing() {
        this.isPairingMode = false;
        this.updateStatusUI();
    }

    // Helper to update the small text on the HUD
    updateStatusUI() {
        const statusDiv = document.getElementById('gamepad-status');
        const p1State = this.controllers.p1 !== null ? "Active" : "Off";
        const p2State = this.controllers.p2 !== null ? "Active" : "Off";
        statusDiv.innerHTML = `<div class="gp-icon"></div> P1: ${p1State} | P2: ${p2State}`;
        statusDiv.classList.add('active');
    }

    // Helper to update the Modal UI
    updatePairingUI() {
        const stepText = document.getElementById('pair-step-indicator');
        const targetText = document.getElementById('target-player');
        const listText = document.getElementById('connected-list');

        if (this.pairingStep === 1) {
            stepText.innerText = "ç­‰å¾… P1 é…å¯¹...";
            stepText.style.color = "#ff3b30";
            targetText.innerText = "P1";
        } else if (this.pairingStep === 2) {
            stepText.innerText = "P1 å·²è¿æ¥! ç­‰å¾… P2 é…å¯¹...";
            stepText.style.color = "#007aff";
            targetText.innerText = "P2";
        } else {
            stepText.innerText = "é…å¯¹å®Œæˆ!";
            stepText.style.color = "#34c759";
            targetText.innerText = "ä»»æ„";
            setTimeout(() => closePairing(), 1000);
        }

        listText.innerHTML = `P1 ID: ${this.controllers.p1 ?? '--'} <br> P2 ID: ${this.controllers.p2 ?? '--'}`;
    }

    update() {
        const pads = navigator.getGamepads();
        if (!pads) return;

        // --- 1. PAIRING LOGIC ---
        if (this.isPairingMode) {
            for (let i = 0; i < pads.length; i++) {
                const gp = pads[i];
                if (gp) {
                    // Detect ZL (B6) + ZR (B7) press
                    if (gp.buttons[6].pressed && gp.buttons[7].pressed) {
                        if (this.pairingStep === 1) {
                            this.controllers.p1 = gp.index;
                            createPopup(CANVAS_W/2, CANVAS_H/2, "P1 LINKED!", "#ff3b30");
                            this.pairingStep = 2;
                            // Debounce slightly to prevent double mapping
                            this.isPairingMode = false; // Pause briefly
                            setTimeout(() => { this.isPairingMode = true; this.updatePairingUI(); }, 1000); 
                        } else if (this.pairingStep === 2 && gp.index !== this.controllers.p1) {
                            this.controllers.p2 = gp.index;
                            createPopup(CANVAS_W/2, CANVAS_H/2, "P2 LINKED!", "#007aff");
                            this.pairingStep = 3;
                            this.updatePairingUI();
                        }
                    }
                }
            }
            return; // Stop here if pairing
        }

        // --- 2. MENU LOGIC (Character Select) ---
        if (gameState === 'menu') {
            this.handleMenuInput(pads, 'p1', this.controllers.p1);
            this.handleMenuInput(pads, 'p2', this.controllers.p2);
            return;
        }

        // --- 3. GAMEPLAY LOGIC ---
        if (gameState === 'playing' && this.active) {
            if (players[0] && this.controllers.p1 !== null) this.handlePlayerInput(pads[this.controllers.p1], players[0]);
            if (players[1] && this.controllers.p2 !== null) this.handlePlayerInput(pads[this.controllers.p2], players[1]);
        }
    }

    handleMenuInput(pads, playerKey, padIndex) {
        if (padIndex === null || !pads[padIndex]) return;
        
        const gp = pads[padIndex];
        // Cooldown for menu navigation
        if (this.menuCooldown[playerKey] > 0) {
            this.menuCooldown[playerKey]--;
        } else {
            // Right Stick X (Axis 2) for navigation (or Left Stick Axis 0)
            const axisX = Math.abs(gp.axes[2]) > 0.5 ? gp.axes[2] : (Math.abs(gp.axes[0]) > 0.5 ? gp.axes[0] : 0);
            
            if (Math.abs(axisX) > 0.5) {
                navigateCharSelect(playerKey, axisX > 0 ? 1 : -1);
                this.menuCooldown[playerKey] = 15; // Delay between moves
                soundManager.play('ui', 1.2);
            }
        }

        // Button 0 (A/B) to Select/Confirm
        if (gp.buttons[0].pressed) {
             if (this.menuCooldown[playerKey] === 0) {
                 confirmCharSelect(playerKey);
                 this.menuCooldown[playerKey] = 30; // Long delay after select
             }
        }
    }

    handlePlayerInput(gp, player) {
        if (!gp || player.lives <= 0) return;

        // Stick Movement
        const rawX = gp.axes[0];
        const rawY = gp.axes[1];
        if (Math.abs(rawX) > this.deadzone) {
            player.move(rawX);
        } else {
            player.move(0); // Stop if stick released
        }
        
        if (rawY > 0.5) player.dropDown();

        // Button Actions
        player.isAtkHeld = gp.buttons[7].pressed; // ZR
        if (gp.buttons[0].pressed) player.jump();   // B / A
        if (gp.buttons[1].pressed) player.useSkill(); // A / B
        if (gp.buttons[3].pressed) player.useUlt();   // X / Y
        if (gp.buttons[6].pressed) player.switchPosition(); // ZL
    }
}

/** * -----------------------------------------------------
 * Game Constants & Globals
 * -----------------------------------------------------
 */
const CANVAS_W = 1000;
const CANVAS_H = 700;
const GRAVITY = 0.8;
const BASE_SPEED = 5;
const BASE_JUMP = -16.0; 
const SWAP_COOLDOWN = 600; 

const CHARACTERS = {
    mage: { 
        name: "æ³•å¸ˆ", icon: "ğŸ§™â€â™‚ï¸", hp: 4, color: "#5ac8fa", resourceType: "mana", maxResource: 100, 
        desc: "æ¿€å…‰ç‚® / è“„åŠ›æ™®æ”»", atkCost: 10, atkDmg: 1, ultCost: 60
    },
    warrior: { 
        name: "æˆ˜å£«", icon: "âš”ï¸", hp: 5, color: "#ff3b30", resourceType: "rage", maxResource: 100, 
        desc: "å†²é”‹ / ç‹‚æš´", atkCost: 0, atkDmg: 1, skillCost: 30, ultCost: 80
    },
    tank: { 
        name: "å¦å…‹", icon: "ğŸ›¡ï¸", hp: 6, color: "#34c759", resourceType: "cooldown", maxResource: 100, 
        desc: "å‡»é€€ / æ¦‚ç‡æ ¼æŒ¡", atkCost: 0, atkDmg: 1
    },
    marksman: { 
        name: "å°„æ‰‹", icon: "ğŸ”«", hp: 4, color: "#ffcc00", resourceType: "energy", maxResource: 100, 
        desc: "ç¿»æ»š / éœ°å¼¹", atkCost: 5, atkDmg: 1, skillCost: 25, ultCost: 60
    },
    ghost: { 
        name: "å¹½çµ", icon: "ğŸ‘»", hp: 1, color: "#af52de", resourceType: "cooldown", maxResource: 100, 
        desc: "éšèº« / é’©å­", atkCost: 0, atkDmg: 1
    },
    gambler: {
        name: "èµŒå¾’", icon: "ğŸ²", hp: 5, color: "#d4af37", resourceType: "cooldown", maxResource: 100,
        desc: "é£ç‰Œ / å‘½è¿è½®ç›˜ / å­¤æ³¨ä¸€æ·", atkCost: 0, atkDmg: 1
    },
    demolitionist: {
        name: "çˆ†ç ´ä¸“å®¶", icon: "ğŸ’£", hp: 5, color: "#ff9500", resourceType: "ammo", maxResource: 3,
        desc: "æ¦´å¼¹ / C4é™·é˜± / åœ°æ¯¯å¼è½°ç‚¸", atkCost: 1, atkDmg: 1, skillCost: 1, ultCost: 2
    },
    illusionist: {
        name: "å¹»æœ¯å¸ˆ", icon: "ğŸ­", hp: 3, color: "#ff2d55", resourceType: "cooldown", maxResource: 100,
        desc: "å¹»å…‰æŸ / é•œåƒåˆ†èº« / ä½ç½®ç½®æ¢", atkCost: 0, atkDmg: 0.5, skillCost: 0, ultCost: 0
    },
    // --- NEW CHARACTER: PALADIN ---
    paladin: {
        name: "åœ£éª‘å£«", icon: "ğŸ›¡ï¸", hp: 6, color: "#ffd60a", resourceType: "faith", maxResource: 100,
        desc: "æˆ˜é”¤ / åœ£å…‰æŠ¤ç›¾(åå¼¹) / åˆ¶è£ä¹‹å…‰", atkCost: 0, atkDmg: 1, skillCost: 30, ultCost: 70
    },
    // --- NEW CHARACTER: CHRONOMANCER ---
    chronomancer: {
        name: "æ—¶ç©ºè¡Œè€…", icon: "â³", hp: 3, color: "#5e5ce6", resourceType: "energy", maxResource: 100,
        desc: "æ—¶é—´é’ˆ / æ—¶é—´å€’æµ / é™æ­¢åŠ›åœº", atkCost: 0, atkDmg: 1, skillCost: 50, ultCost: 100
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameLoopId;
let lastTime = 0;
let globalTime = 0; 

const keys = {};
let players = [];
let projectiles = [];
let particles = [];
let platforms = [];
let spikeState = { active: false, timer: 0 };
let popups = []; 

let gameState = 'menu'; 
let p1Char = null;
let p2Char = null;
const gamepadHandler = new GamepadHandler();

// Global Selection State
let selectionState = {
    p1: { index: 0, confirmed: false },
    p2: { index: 1, confirmed: false }
};
const charKeys = Object.keys(CHARACTERS);

/**
 * Initializers
 */
function initMap() {
    platforms = [];
    platforms.push({ x: 0, y: 650, w: 1000, h: 50, type: 'ground', level: 1 });
    platforms.push({ x: 100, y: 500, w: 200, h: 20, type: 'platform', level: 2, effect: 'jump' });
    platforms.push({ x: 700, y: 500, w: 200, h: 20, type: 'platform', level: 2, effect: 'jump' });
    platforms.push({ x: 0, y: 350, w: 150, h: 20, type: 'platform', level: 3, effect: 'slow' });
    platforms.push({ x: 850, y: 350, w: 150, h: 20, type: 'platform', level: 3, effect: 'slow' });
    platforms.push({ x: 350, y: 200, w: 300, h: 20, type: 'platform', level: 4, effect: 'speed' });
}

window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// Populate Char Select with New Structure
const charContainer = document.getElementById('char-selection');
charContainer.innerHTML = ''; // Clear existing
charKeys.forEach((key, index) => {
    const char = CHARACTERS[key];
    const div = document.createElement('div');
    div.className = 'char-card';
    div.id = `char-card-${index}`; // Add ID for easy access
    // Added indicator spans
    div.innerHTML = `
        <span class="p1-cursor-indicator">ğŸ”»</span>
        <span class="p2-cursor-indicator">ğŸ”»</span>
        <div class="char-icon">${char.icon}</div>
        <h3>${char.name}</h3>
        <div class="char-desc">HP: ${char.hp}<br>${char.desc}</div>
    `;
    
    // Mouse support remains
    div.addEventListener('click', () => { 
        selectionState.p1.index = index; 
        confirmCharSelect('p1'); 
    });
    div.addEventListener('contextmenu', (e) => { 
        e.preventDefault(); 
        selectionState.p2.index = index; 
        confirmCharSelect('p2'); 
    });
    
    charContainer.appendChild(div);
});

// Initial Highlight
updateCharHighlights();

function navigateCharSelect(playerKey, direction) {
    if (selectionState[playerKey].confirmed) return; // Locked if confirmed

    let newIdx = selectionState[playerKey].index + direction;
    if (newIdx < 0) newIdx = charKeys.length - 1;
    if (newIdx >= charKeys.length) newIdx = 0;
    
    selectionState[playerKey].index = newIdx;
    updateCharHighlights();
}

function confirmCharSelect(playerKey) {
    const key = charKeys[selectionState[playerKey].index];
    
    if (playerKey === 'p1') {
        p1Char = key;
        selectionState.p1.confirmed = true;
    } else {
        p2Char = key;
        selectionState.p2.confirmed = true;
    }
    
    soundManager.play('ui', 1.0);
    updateCharHighlights();
    updateSelectionUI(); // Call original function to update borders/start btn
}

function updateCharHighlights() {
    // Clear hover classes
    document.querySelectorAll('.char-card').forEach(c => {
        c.classList.remove('hover-p1', 'hover-p2');
    });

    // Add visual cursor for P1
    const p1Card = document.getElementById(`char-card-${selectionState.p1.index}`);
    if (p1Card) p1Card.classList.add('hover-p1');

    // Add visual cursor for P2
    const p2Card = document.getElementById(`char-card-${selectionState.p2.index}`);
    if (p2Card) p2Card.classList.add('hover-p2');
}

function updateSelectionUI() {
    document.querySelectorAll('.char-card').forEach((c, idx) => {
        c.classList.remove('selected-p1', 'selected-p2', 'selected-both');
        const k = charKeys[idx];
        if (p1Char === k && p2Char === k) c.classList.add('selected-both');
        else if (p1Char === k) c.classList.add('selected-p1');
        else if (p2Char === k) c.classList.add('selected-p2');
    });
    if (p1Char && p2Char) document.getElementById('start-btn').style.display = 'block';
}

document.getElementById('start-btn').addEventListener('click', startGame);

// Pairing Modal Logic
function openPairing() {
    document.getElementById('settings-modal').style.display = 'none'; // Hide settings
    document.getElementById('pairing-modal').style.display = 'flex';
    gamepadHandler.startPairing();
}

function closePairing() {
    document.getElementById('pairing-modal').style.display = 'none';
    document.getElementById('settings-modal').style.display = 'flex'; // Back to settings
    gamepadHandler.stopPairing();
}

// Menu Loop for Gamepad Polling
function menuLoop() {
    if (gameState === 'menu') {
        gamepadHandler.update(); // Poll inputs for char select
        requestAnimationFrame(menuLoop);
    }
}

/**
 * Logic Classes
 */
class Player {
    constructor(id, charKey, x, y) {
        this.id = id;
        this.charKey = charKey;
        this.stats = CHARACTERS[charKey];
        
        this.x = x; this.y = y; this.w = 30; this.h = 50;
        this.vx = 0; this.vy = 0;
        this.grounded = false; this.platform = null; 
        this.inputX = 0; 
        this.isAtkHeld = false;
        
        this.lives = 3;
        this.maxHp = this.stats.hp;
        this.hp = this.maxHp;
        this.dir = id === 1 ? 1 : -1; 
        
        this.resource = 100; 
        if (this.charKey === 'demolitionist') this.resource = 3; // Start with 3 ammo

        this.cdAtk = 0; this.cdSkill = 0; this.cdUlt = 0; this.cdSwap = 0;
        
        this.invuln = 0; 
        this.buffSpeed = false; this.buffJump = false; this.debuffSlow = false;
        this.invisible = false; this.invisibleTimer = 0; // Ghost property
        this.charging = false; this.chargeTimer = 0;
        this.raging = 0; this.stunned = 0; this.tankUlt = 0; this.nextHitStun = false; 
        this.reflecting = 0; // Paladin Reflect
        this.faithRegenTimer = 0; // Paladin Regen
        
        this.doubleDamageTimer = 0; // Ghost Ult Buff
        this.dropCooldown = 0; // Timer to ignore platform collision
        this.activeC4 = null; // Demolitionist C4 Tracker
        this.ammoRegenTimer = 0; // Demolitionist Regen
        // Illusionist Clone
        this.clone = { active: false, x: 0, y: 0, dir: 1 };
        // Chronomancer History
        this.history = []; 
        this.energyRegenTimer = 0; // Chronomancer

        this.actionState = 'idle'; this.actionTimer = 0; this.atkAnimTimer = 0;
        this.mageChargingAtk = false; this.mageChargeAtkTimer = 0;

        if (id === 1) this.keys = { l:'a', r:'d', u:'w', d:'s', atk:'x', skill:'c', ult:'v', swap:'f' };
        else this.keys = { l:'j', r:'l', u:'i', d:'k', atk:',', skill:'.', ult:'/', swap:';' };
    }

    move(normalizedX) { this.inputX = normalizedX; }
    jump() {
        if (!this.isLocked() && this.grounded) {
            let jumpPower = BASE_JUMP;
            if (this.buffJump) jumpPower *= 1.5;
            this.vy = jumpPower;
            this.grounded = false;
            this.platform = null;
            soundManager.play('jump', this.id === 1 ? 1 : 0.8);
        }
    }
    dropDown() {
        if (!this.isLocked() && this.grounded && this.platform && this.platform.type !== 'ground') {
            this.dropCooldown = 20; 
            this.grounded = false; 
            this.platform = null;
            this.y += 2; 
        }
    }
    useUltimate() { this.useUlt(); }
    switchPosition() { this.useSwap(); }
    isLocked() { return this.stunned > 0 || this.charging || this.actionState !== 'idle'; }

    update() {
        if (this.lives <= 0) return;

        // GOD MODE
        if (Settings.noCooldown) {
            this.resource = (this.charKey === 'demolitionist') ? 3 : 100;
            if(this.cdSkill > 0) this.cdSkill = 0;
            if(this.cdUlt > 0) this.cdUlt = 0;
            if(this.cdSwap > 0) this.cdSwap = 0;
            if(this.cdAtk > 5) this.cdAtk = 5; 
        }

        if (this.invuln > 0) this.invuln--;
        if (this.cdAtk > 0) this.cdAtk--;
        if (this.cdSkill > 0) this.cdSkill--;
        if (this.cdUlt > 0) this.cdUlt--;
        if (this.cdSwap > 0) this.cdSwap--;
        if (this.stunned > 0) this.stunned--;
        if (this.atkAnimTimer > 0) this.atkAnimTimer--;
        if (this.doubleDamageTimer > 0) this.doubleDamageTimer--;
        if (this.dropCooldown > 0) this.dropCooldown--; 
        if (this.reflecting > 0) this.reflecting--;
        
        // Chronomancer History
        if (this.charKey === 'chronomancer') {
            this.history.push({ x: this.x, y: this.y, hp: this.hp });
            if (this.history.length > 300) this.history.shift();
        }
        
        if (this.actionState !== 'idle') {
            this.actionTimer--;
            if (this.actionState === 'rolling') this.invuln = 2; 
            else if (this.actionState === 'dashing') {
                let enemy = this.id === 1 ? players[1] : players[0];
                if (Math.abs((enemy.y + enemy.h/2) - (this.y + this.h/2)) < 60 &&
                    Math.abs((enemy.x + enemy.w/2) - (this.x + this.w/2)) < 60) {
                    enemy.x = this.x + (this.dir * (this.w + 5));
                    enemy.stunned = 2; 
                }
            }
            if (this.actionTimer <= 0) { this.actionState = 'idle'; this.vx = 0; }
        }

        if (this.stunned > 0) { 
            if (this.charKey === 'ghost' && keys[this.keys.skill] && this.cdSkill <= 0) {
                this.useSkill();
            }
            this.vx = 0; 
            this.applyPhysics(); 
            return; 
        }
        
        // Mage Charge Ult
        if (this.charging) {
            this.vx = 0;
            this.chargeTimer--;
            if (Settings.flashyMode) spawnFlashyParticles(this.x+this.w/2, this.y+this.h/2, this.stats.color, 'charge');
            else if (Math.random() < 0.5) particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, "#5ac8fa", 'aura'));
            
            if (this.chargeTimer <= 0) { this.charging = false; this.fireLaser(); }
            if (keys[this.keys.l]) this.vx = -BASE_SPEED * 0.2;
            if (keys[this.keys.r]) this.vx = BASE_SPEED * 0.2;
            this.applyPhysics();
            return;
        }

        // Warrior Rage - Enhanced with rising smoke
        if (this.raging > 0) {
             this.raging--;
             // Add irregular rising red smoke particles
             if (Math.random() < 0.4) {
                 let p = new Particle(this.x + Math.random()*this.w, this.y + this.h, "#ff3b30", 'rage_smoke');
                 p.vx = (Math.random() - 0.5) * 2;
                 p.vy = -2 - Math.random() * 2;
                 p.life = 30;
                 p.size = 6;
                 particles.push(p);
             }
             if (Settings.flashyMode) spawnFlashyParticles(this.x+Math.random()*this.w, this.y+Math.random()*this.h, "#ff0000", 'rage');
             else if (Math.random() < 0.3) particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, "#ff3b30", 'aura'));
        }
        
        // Ghost Invisible
        if (this.invisible) {
            this.invisibleTimer--;
            if (this.invisibleTimer <= 0) this.invisible = false;
        }
        if (this.tankUlt > 0) this.tankUlt--;

        if (!Settings.noCooldown) {
            // Marksman Energy
            if (this.charKey === 'marksman' && this.resource < 100 && globalTime % 12 === 0) this.resource++;
            // Demolitionist Ammo
            if (this.charKey === 'demolitionist' && this.resource < 3) {
                this.ammoRegenTimer++;
                if (this.ammoRegenTimer >= 180) { // 3 seconds at 60fps
                    this.resource++;
                    this.ammoRegenTimer = 0;
                    createPopup(this.x, this.y - 30, "+1 Ammo", "#ff9500");
                }
            }
            // Paladin Faith / Chronomancer Energy (10 per sec -> 1 every 6 frames)
            if ((this.charKey === 'paladin' || this.charKey === 'chronomancer') && this.resource < 100) {
                this.faithRegenTimer++; // Reusing var name for chrono too
                if (this.faithRegenTimer >= 6) {
                    this.resource++;
                    this.faithRegenTimer = 0;
                }
            }
        }

        if (!this.isLocked()) {
            let speed = BASE_SPEED;
            if (this.buffSpeed) speed *= 1.5; // Gambler: 1.5x, others 2x if map effect? Adjusted to match map effect or Gambler skill
            if (this.platform && this.platform.level === 4) speed *= 2; // Map effect override

            if (this.raging > 0) speed *= 2;
            if (this.debuffSlow) speed /= 2;
            this.vx = 0;
            if (keys[this.keys.l]) { this.vx = -speed; this.dir = -1; }
            if (keys[this.keys.r]) { this.vx = speed; this.dir = 1; }
            if (Math.abs(this.inputX) > 0.05) { this.vx = this.inputX * speed; this.dir = this.inputX > 0 ? 1 : -1; }
            if (keys[this.keys.u] && this.grounded) this.jump();
            if (keys[this.keys.d]) this.dropDown();
        }

        this.applyPhysics();
        this.checkMapEffects();
        
        if (!this.isLocked()) {
            const pressingAtk = keys[this.keys.atk] || this.isAtkHeld;
            
            if (this.charKey === 'mage') {
                if (pressingAtk) {
                    this.mageChargingAtk = true;
                    this.mageChargeAtkTimer++;
                    if (this.mageChargeAtkTimer % 10 === 0) {
                        particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, "#5ac8fa", 'spark'));
                    }
                } else {
                    if (this.mageChargingAtk) {
                        let dmg = (this.mageChargeAtkTimer > 120) ? 2 : 1;
                        if (this.cdAtk <= 0) this.attack(dmg);
                        this.mageChargingAtk = false;
                        this.mageChargeAtkTimer = 0;
                    }
                }
            } else {
                if (pressingAtk && this.cdAtk <= 0) this.attack();
            }

            if (keys[this.keys.skill] && this.cdSkill <= 0) this.useSkill();
            if (keys[this.keys.ult] && this.cdUlt <= 0) this.useUlt();
            if (keys[this.keys.swap] && this.cdSwap <= 0) this.useSwap();
        }
    }

    applyPhysics() {
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0) this.x = 0;
        if (this.x + this.w > CANVAS_W) this.x = CANVAS_W - this.w;
        this.grounded = false;
        for (let p of platforms) {
            if (this.dropCooldown > 0 && p.type !== 'ground') continue;
            
            if (this.vy >= 0 && this.y + this.h >= p.y && this.y + this.h <= p.y + p.h + 10 && this.x + this.w > p.x && this.x < p.x + p.w) {
                this.y = p.y - this.h; this.vy = 0; this.grounded = true; this.platform = p;
            }
        }
    }

    checkMapEffects() {
        let onSpecialPlat = false;
        if (this.grounded && this.platform) {
            if (this.platform.level === 2) { this.buffJump = true; onSpecialPlat = true; }
            else if (this.platform.level === 3) { this.debuffSlow = true; onSpecialPlat = true; }
            else if (this.platform.level === 4) { this.buffSpeed = true; onSpecialPlat = true; }
        }
        if (!onSpecialPlat) {
            // Keep buffSpeed if it came from Gambler Skill
            if (this.charKey !== 'gambler' || (this.charKey === 'gambler' && this.buffDuration <= 0)) {
                 this.buffSpeed = false; 
            }
            this.buffJump = false; this.debuffSlow = false;
        }
        
        if (this.buffDuration > 0) {
            this.buffDuration--;
            if (this.buffDuration <= 0) {
                this.buffSpeed = false;
                createPopup(this.x, this.y, "Buff End", "#ccc");
            }
        }
    }

    takeDamage(amount, type = 'normal') {
        if (this.lives <= 0 || this.invuln > 0) return;
        
        if (type === 'spike' && this.invisible) return;

        if (this.tankUlt > 0 && Math.random() < 0.5) {
            createPopup(this.x, this.y, "Blocked!", "#34c759");
            spawnFlashyParticles(this.x+this.w/2, this.y+this.h/2, "#34c759", "block");
            return;
        }
        
        if (!Settings.noCooldown && this.charKey === 'warrior' && this.resource < 100) this.resource = Math.min(100, this.resource + 5);

        this.hp -= amount;
        if (this.hp < 0) this.hp = 0; // Prevent negative display issues
        
        soundManager.play('hit', 1.0);
        createPopup(this.x, this.y, `-${amount}`, "#ff3b30");
        spawnFlashyParticles(this.x+this.w/2, this.y+this.h/2, "#ff3b30", "hit");
        
        if (this.hp <= 0) this.die();
        else this.invuln = 10;
    }

    die() {
        this.lives--;
        createPopup(this.x, this.y, "DEAD", "#ff3b30");
        spawnFlashyParticles(this.x+this.w/2, this.y+this.h/2, this.stats.color, "death");
        if (this.lives > 0) this.respawn();
        else endGame(this.id === 1 ? 2 : 1);
    }

    respawn() {
        if (this.id === 1) { this.x = 50; this.y = 200; } else { this.x = 920; this.y = 200; }
        this.hp = this.maxHp; this.vx = 0; this.vy = 0; this.invuln = 60;
        this.resource = 100; 
        if (this.charKey === 'demolitionist') {
            this.resource = 3; 
            this.activeC4 = null; 
        }
        this.invisible = false; this.raging = 0; this.buffSpeed = false; this.actionState = 'idle'; this.inputX = 0;
        this.doubleDamageTimer = 0;
        this.clone = { active: false, x: 0, y: 0, dir: 1 };
        this.reflecting = 0;
        this.history = [];
    }

    attack(damageOverride = null) {
        if (this.invisible) {
             this.invisible = false;
             createPopup(this.x, this.y, "Revealed!", "#fff");
        }

        if (this.cdAtk > 0) return;
        
        if (!Settings.noCooldown) {
            if (this.charKey === 'mage' && this.resource < 10) return;
            if (this.charKey === 'marksman' && this.resource < 5) return;
            if (this.charKey === 'demolitionist' && this.resource < 1) {
                createPopup(this.x, this.y - 20, "No Ammo!", "#ff9500");
                return;
            }
        }

        this.cdAtk = 30; 
        this.atkAnimTimer = 15; 
        soundManager.play('attack', this.id === 1 ? 1.2 : 0.8);

        let startX = this.dir === 1 ? this.x + this.w : this.x;
        let startY = this.y + this.h / 2;
        let baseDmg = damageOverride || 1;
        
        if (this.doubleDamageTimer > 0) {
            baseDmg *= 2;
            if (Math.random() < 0.5) createPopup(this.x, this.y-20, "Double Dmg!", "#af52de");
        }

        if (this.charKey === 'mage') {
            if (!Settings.noCooldown) this.resource -= 10;
            if (damageOverride === 2) {
                spawnFlashyParticles(startX, startY, "#0000ff", "nova");
                createPopup(this.x, this.y, "MAX CHARGE!", "#5ac8fa");
            }
            projectiles.push(new Projectile(startX, startY, this.dir * 8, 0, this.id, baseDmg, 'fireball'));
            if (Settings.flashyMode) spawnFlashyParticles(startX, startY, "#5ac8fa", "sparkle");
        } else if (this.charKey === 'marksman') {
            if (!Settings.noCooldown) this.resource -= 5;
            projectiles.push(new Projectile(startX, startY, this.dir * 15, 0, this.id, baseDmg, 'bullet'));
            // Muzzle flash particles
            for(let i=0; i<8; i++) {
                let angle = (this.dir === 1 ? 0 : Math.PI) + (Math.random() - 0.5) * 0.5;
                let speed = 3 + Math.random() * 3;
                let p = new Particle(startX, startY, "#ffcc00", 'muzzle_flash');
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 10;
                p.size = 3;
                particles.push(p);
            }
            if (Settings.flashyMode) spawnFlashyParticles(startX, startY, "#ffcc00", "sparkle");
        } else if (this.charKey === 'warrior') {
            this.createMeleeHitbox(60, baseDmg, 0);
            if (!Settings.noCooldown) this.resource = Math.min(100, this.resource + 10);
            if (Settings.flashyMode) spawnFlashyParticles(startX + this.dir*20, startY, "#ff3b30", "slash");
        } else if (this.charKey === 'tank') {
            let hit = this.createMeleeHitbox(50, baseDmg, 0);
            if (hit) {
                let enemy = this.id === 1 ? players[1] : players[0];
                enemy.vx = this.dir * 15; enemy.vy = -5;
                if (this.nextHitStun) { enemy.stunned = 30; createPopup(enemy.x, enemy.y, "Stun!", "#34c759"); this.nextHitStun = false; }
            }
            // Add shockwave effect
            for(let i=0; i<8; i++) {
                let angle = (this.dir === 1 ? 0 : Math.PI) + (i - 4) * 0.15;
                let speed = 3;
                let p = new Particle(this.x + (this.dir === 1 ? this.w : 0), this.y + this.h/2, "#34c759", 'shockwave');
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 15;
                p.size = 5;
                particles.push(p);
            }
        } else if (this.charKey === 'ghost') {
            this.createMeleeHitbox(75, baseDmg, 0);
            // Add ghostly smoke trail
            for(let i=0; i<5; i++) {
                let p = new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, i % 2 === 0 ? "#999" : "#af52de", 'ghost_smoke');
                p.vx = (Math.random() - 0.5) * 2;
                p.vy = (Math.random() - 0.5) * 2;
                p.life = 25;
                p.size = 4;
                particles.push(p);
            }
        } else if (this.charKey === 'gambler') {
            // Random card with height based on suit
            let card = new Projectile(startX, startY, this.dir * 12, 0, this.id, baseDmg, 'card');
            // Adjust launch height based on card suit (set in constructor)
            projectiles.push(card);
            soundManager.play('attack', 1.5); 
        } else if (this.charKey === 'demolitionist') {
            if (!Settings.noCooldown) this.resource -= 1;
            // Parabolic aiming - calculate trajectory to hit enemy or max range
            let enemy = this.id === 1 ? players[1] : players[0];
            let targetX = enemy.x + enemy.w/2;
            let targetY = enemy.y + enemy.h/2;
            let hasEnemy = enemy.lives > 0;

            if (!hasEnemy) {
                // No enemy, shoot to max range
                targetX = this.x + (this.dir * 400);
                if (targetX < 0) targetX = 50;
                if (targetX > CANVAS_W) targetX = CANVAS_W - 50;
                targetY = 650;
            }

            // Calculate parabolic trajectory
            let dx = targetX - startX;
            let dy = targetY - startY;
            let gravity = 0.5;
            let vxGrenade = this.dir * 10;
            let time = Math.abs(dx / vxGrenade);
            let vyGrenade = (dy / time) - (0.5 * gravity * time);

            projectiles.push(new Projectile(startX, startY, vxGrenade, vyGrenade, this.id, baseDmg, 'grenade'));
            createPopup(this.x, this.y - 30, `${this.resource} Ammo`, "#ff9500");
        } else if (this.charKey === 'illusionist') {
            projectiles.push(new Projectile(startX, startY, this.dir * 25, 0, this.id, 0.5, 'illusion_beam'));
            soundManager.play('skill', 2.0);
        } else if (this.charKey === 'paladin') {
            let range = 40;
            let enemy = this.id === 1 ? players[1] : players[0];
            let dist = (enemy.x + enemy.w/2) - (this.x + this.w/2);
            if (Math.abs(dist) < range && Math.abs((enemy.y + enemy.h/2) - (this.y + this.h/2)) < 60) {
                enemy.takeDamage(baseDmg);
            }
            if (Settings.flashyMode) spawnFlashyParticles(this.x + this.w/2, this.y + this.h/2, "#ffd60a", "burst");
        } else if (this.charKey === 'chronomancer') {
            // Chronomancer Attack: Time Needle
            // Speed increased to 15
            projectiles.push(new Projectile(startX, startY, this.dir * 15, 0, this.id, baseDmg, 'time_needle'));
            soundManager.play('attack', 1.3);
        }
    }

    createMeleeHitbox(range, dmg, stunTime) {
        let enemy = this.id === 1 ? players[1] : players[0];
        let dist = (enemy.x + enemy.w/2) - (this.x + this.w/2);
        if ((this.dir === 1 && dist > 0 && dist < range) || (this.dir === -1 && dist < 0 && Math.abs(dist) < range)) {
            if (Math.abs((enemy.y + enemy.h/2) - (this.y + this.h/2)) < 60) {
                enemy.takeDamage(dmg);
                if (stunTime > 0) enemy.stunned = stunTime;
                return true;
            }
        }
        return false;
    }

    useSkill() {
        if (this.charKey !== 'ghost' && this.invisible) this.invisible = false;
        if (this.cdSkill > 0 && this.charKey !== 'demolitionist' && this.charKey !== 'illusionist') return; 
        
        soundManager.play('skill', this.id === 1 ? 1.0 : 0.7);
        if (Settings.flashyMode && this.charKey !== 'illusionist') spawnFlashyParticles(this.x+this.w/2, this.y+this.h/2, this.stats.color, "burst");

        if (this.charKey === 'mage') {
            this.cdSkill = 600; this.resource = 100;
            createPopup(this.x, this.y, "Mana Full", "#5ac8fa");
        }
        else if (this.charKey === 'warrior') {
            if (!Settings.noCooldown && this.resource < 30) return;
            if (!Settings.noCooldown) this.resource -= 30;
            this.cdSkill = 480; this.actionState = 'dashing'; this.actionTimer = 24; this.vx = this.dir * 8; this.invuln = 10;
        }
        else if (this.charKey === 'tank') {
            this.cdSkill = 300; this.nextHitStun = true; createPopup(this.x, this.y, "Stun Ready", "#34c759");
        }
        else if (this.charKey === 'marksman') {
            if (!Settings.noCooldown && this.resource < 25) return;
            if (!Settings.noCooldown) this.resource -= 25;
            this.cdSkill = 300; this.actionState = 'rolling'; this.actionTimer = 10; this.vx = this.dir * 15; this.invuln = 30;
        }
        else if (this.charKey === 'ghost') {
            this.cdSkill = 600; 
            this.invisible = true; 
            this.invisibleTimer = 600; 
            
            if (this.stunned > 0) {
                this.stunned = 0;
                createPopup(this.x, this.y, "CLEANSED!", "#fff");
            }
            
            createPopup(this.x, this.y, "Invisible (10s)", "#af52de");
        }
        else if (this.charKey === 'gambler') {
            this.cdSkill = 300; // 5 seconds CD
            const roll = Math.random();
            this.rouletteAnim = 30;

            if (roll < 1/3) {
                this.buffSpeed = true; this.buffDuration = 180;
                createPopup(this.x, this.y - 40, "JACKPOT! Speed Up", "#34c759");
            } else if (roll < 2/3) {
                this.cdUlt = 0; createPopup(this.x, this.y - 40, "LUCKY! Ult Reset", "#007aff");
            } else {
                this.stunned = 60; createPopup(this.x, this.y - 40, "BUST! Stunned", "#ff3b30");
            }
        }
        else if (this.charKey === 'demolitionist') {
            if (this.activeC4 && this.activeC4.active) {
                this.activeC4.life = 0; 
                this.activeC4 = null;
                this.cdSkill = 60; 
                return;
            }
            if (this.cdSkill > 0) return;
            if (!Settings.noCooldown && this.resource < 1) {
                createPopup(this.x, this.y - 20, "No Ammo!", "#ff9500");
                return;
            }
            if (!Settings.noCooldown) this.resource -= 1;
            
            let c4 = new Projectile(this.x + this.w/2 - 10, this.y + this.h - 5, 0, 0, this.id, 1, 'c4_trap');
            projectiles.push(c4);
            this.activeC4 = c4;
            this.cdSkill = 30; 
            createPopup(this.x, this.y - 30, "C4 Set", "#ff9500");
            return;
        }
        else if (this.charKey === 'illusionist') {
            if (this.clone.active) {
                spawnFlashyParticles(this.x, this.y, "#ff2d55", "dash"); 
                this.x = this.clone.x;
                this.y = this.clone.y;
                this.dir = this.clone.dir;
                this.vx = 0; this.vy = 0;
                spawnFlashyParticles(this.x, this.y, "#00ffff", "burst"); 
                createPopup(this.x, this.y - 40, "Return!", "#00ffff");
                this.clone.active = false;
                this.cdSkill = 300; 
                return;
            }
            if (this.cdSkill > 0) return;
            
            this.clone.x = this.x;
            this.clone.y = this.y;
            this.clone.dir = this.dir;
            this.clone.active = true;

            let dashDist = 100;
            let targetX = this.x + (this.dir * dashDist);
            if (targetX < 0) targetX = 0;
            if (targetX > CANVAS_W - this.w) targetX = CANVAS_W - this.w;
            
            this.x = targetX;
            this.y -= 5; 
            
            createPopup(this.clone.x, this.clone.y - 40, "Clone!", "#ff2d55");
            this.cdSkill = 30; 
            return;
        }
        else if (this.charKey === 'paladin') {
            if (!Settings.noCooldown && this.resource < 30) {
                createPopup(this.x, this.y - 20, "Need Faith", "#ffd60a");
                return;
            }
            if (!Settings.noCooldown) this.resource -= 30;
            
            this.cdSkill = 600; 
            this.reflecting = 60; 
            createPopup(this.x, this.y - 40, "SHIELD!", "#ffd60a");
        }
        else if (this.charKey === 'chronomancer') {
            // Skill: Time Rewind
            if (!Settings.noCooldown && this.resource < 50) {
                createPopup(this.x, this.y - 20, "Need Energy", "#5e5ce6");
                return;
            }
            if (!Settings.noCooldown) this.resource -= 50;
            this.cdSkill = 600; // 10s

            if (this.history.length > 0) {
                let oldState = this.history[0]; // Oldest state (approx 3s ago)
                spawnFlashyParticles(this.x, this.y, "#5e5ce6", "dash"); // Leave trail
                
                // Rewind
                this.x = oldState.x;
                this.y = oldState.y;
                if (oldState.hp > this.hp) {
                    let heal = oldState.hp - this.hp;
                    this.hp = oldState.hp;
                    createPopup(this.x, this.y - 40, `Rewind +${heal}HP`, "#00ff00");
                } else {
                    createPopup(this.x, this.y - 40, "Rewind!", "#5e5ce6");
                }
                spawnFlashyParticles(this.x, this.y, "#5e5ce6", "burst");
            } else {
                createPopup(this.x, this.y - 40, "No History", "#ccc");
            }
        }
    }

    useUlt() {
        if (this.invisible) {
            this.invisible = false;
            createPopup(this.x, this.y, "Revealed!", "#fff");
        }
        if (this.cdUlt > 0) return;
        
        soundManager.play('ult', 1.0);
        if (Settings.flashyMode) spawnFlashyParticles(this.x+this.w/2, this.y, this.stats.color, "nova");

        if (this.charKey === 'mage') {
            if (!Settings.noCooldown && this.resource < 60) return;
            if (!Settings.noCooldown) this.resource -= 60;
            this.charging = true; 
            this.chargeTimer = 60; 
        }
        else if (this.charKey === 'warrior') {
            if (!Settings.noCooldown && this.resource < 80) return;
            if (!Settings.noCooldown) this.resource -= 80;
            this.raging = 300; createPopup(this.x, this.y, "RAGE!", "#ff3b30");
        }
        else if (this.charKey === 'tank') {
            this.cdUlt = 1080; this.tankUlt = 180; createPopup(this.x, this.y, "Guard Up", "#34c759");
        }
        else if (this.charKey === 'marksman') {
            if (!Settings.noCooldown && this.resource < 60) return;
            if (!Settings.noCooldown) this.resource -= 60;
            for(let i=0; i<20; i++) {
                 let angle = (Math.random() - 0.5) * 1; let speed = Math.random() * 5 + 2;
                 let p = new Particle(this.x+(this.dir===1?this.w:0), this.y+this.h/2, "#ff9500", 'spark');
                 p.vx = (this.dir * speed) + Math.cos(angle)*2; p.vy = Math.sin(angle) * 2;
                 particles.push(p);
            }
            for(let i=-2; i<=2; i++) {
                let vy = i * 2; projectiles.push(new Projectile(this.x + (this.dir===1?this.w:0), this.y + this.h/2, this.dir * 12, vy, this.id, 1, 'bullet'));
            }
        }
        else if (this.charKey === 'ghost') {
            this.cdUlt = 600; 
            projectiles.push(new Projectile(this.x, this.y + this.h/2, this.dir * 30, 0, this.id, 0, 'hook'));
        }
        else if (this.charKey === 'gambler') {
            this.cdUlt = 900;
            for(let i=0; i<3; i++) {
                let vy = -10 - (i * 3); // Much higher bounce with increased upward velocity
                let vx = this.dir * (6 + i * 2);
                projectiles.push(new Projectile(this.x, this.y, vx, vy, this.id, 1, 'dice_boulder'));
            }
        }
        else if (this.charKey === 'demolitionist') {
            if (!Settings.noCooldown && this.resource < 2) {
                createPopup(this.x, this.y - 20, "Need 2 Ammo!", "#ff9500");
                return;
            }
            if (!Settings.noCooldown) this.resource -= 2;
            this.cdUlt = 900;

            for(let i=1; i<=3; i++) {
                let targetX = this.x + (this.dir * (150 * i));
                targetX = Math.max(50, Math.min(CANVAS_W - 50, targetX));
                let bomb = new Projectile(targetX, -50, 0, 5, this.id, 2, 'carpet_bomb');
                bomb.life = 120;
                bomb.tickTimer = i * 15;
                bomb.targetY = 650; // Ground level
                projectiles.push(bomb);
            }
            createPopup(this.x, this.y - 40, "INCOMING!", "#ff3b30");
        }
        else if (this.charKey === 'illusionist') {
            this.cdUlt = 1200; 
            projectiles.push(new Projectile(this.x, this.y + this.h/2, this.dir * 20, 0, this.id, 0, 'swap_bullet'));
            createPopup(this.x, this.y - 40, "BANISH!", "#af52de");
        }
        else if (this.charKey === 'paladin') {
            if (!Settings.noCooldown && this.resource < 70) {
                createPopup(this.x, this.y - 20, "Need 70 Faith!", "#ffd60a");
                return;
            }
            if (!Settings.noCooldown) this.resource -= 70;
            
            this.cdUlt = 1200;
            let targetX = this.x + (this.dir * 100);
            if(targetX < 50) targetX = 50;
            if(targetX > CANVAS_W-50) targetX = CANVAS_W-50;
            
            projectiles.push(new Projectile(targetX, 0, 0, 0, this.id, 1, 'light_pillar'));
            createPopup(this.x, this.y - 40, "JUDGMENT!", "#ffd60a");
        }
        else if (this.charKey === 'chronomancer') {
            // Chronomancer Ult: Stasis Field
            if (!Settings.noCooldown && this.resource < 100) {
                createPopup(this.x, this.y - 20, "Need 100 Energy!", "#5e5ce6");
                return;
            }
            if (!Settings.noCooldown) this.resource -= 100;
            this.cdUlt = 1200; // 20s

            projectiles.push(new Projectile(this.x + (this.dir*40), this.y + this.h/2 - 40, this.dir * 2, 0, this.id, 0, 'stasis_field'));
            createPopup(this.x, this.y - 40, "TIME STOP!", "#5e5ce6");
        }
    }

    fireLaser() {
        let laserY = this.y + this.h/2;
        projectiles.push(new Projectile(0, laserY, 0, 0, this.id, 1, 'mage_ult'));
        if (Settings.flashyMode) spawnFlashyParticles(this.x, laserY, "#5ac8fa", "beam_trail");
    }

    useSwap() {
        if (this.cdSwap > 0) return;
        this.cdSwap = SWAP_COOLDOWN;
        let other = this.id === 1 ? players[1] : players[0];
        let tx = this.x; let ty = this.y;
        this.x = other.x; this.y = other.y;
        other.x = tx; other.y = ty;
        createPopup(this.x, this.y, "SWAP!", "#af52de"); createPopup(other.x, other.y, "SWAP!", "#af52de");
        if (Settings.flashyMode) {
            spawnFlashyParticles(this.x, this.y, "#af52de", "burst");
            spawnFlashyParticles(other.x, other.y, "#af52de", "burst");
        }
        soundManager.play('skill', 1.5);
    }

    drawHexagon(ctx, cx, cy, size) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            let angle = Math.PI / 3 * i;
            let x = cx + size * Math.cos(angle);
            let y = cy + size * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
    }

    draw(ctx) {
         if (this.lives <= 0) return;
         
         if (this.invisible) {
             let blinkCycle = this.invisibleTimer % 90;
             if (blinkCycle > 10) return; 
             ctx.globalAlpha = 0.4; 
         }
         
         // Draw Illusionist Clone
         if (this.clone.active) {
             ctx.save();
             ctx.globalAlpha = 0.5;
             ctx.fillStyle = this.stats.color; 
             ctx.fillRect(this.clone.x, this.clone.y, this.w, this.h);
             ctx.fillStyle = "#fff";
             if (this.clone.dir === 1) ctx.fillRect(this.clone.x + 20, this.clone.y + 10, 5, 5);
             else ctx.fillRect(this.clone.x + 5, this.clone.y + 10, 5, 5);
             ctx.restore();
         }
         
         if (this.raging > 0) {
             ctx.save();
             ctx.strokeStyle = `rgba(255, 59, 48, ${(this.raging % 20) / 20})`;
             ctx.lineWidth = 3;
             ctx.strokeRect(this.x-5, this.y-5, this.w+10, this.h+10);
             ctx.restore();
         }

         if (this.tankUlt > 0) {
             ctx.save();
             ctx.strokeStyle = "#34c759";
             ctx.lineWidth = Settings.flashyMode ? 6 : 3;
             if (Settings.flashyMode) ctx.shadowBlur = 15; ctx.shadowColor = "#34c759";

             // Draw honeycomb hexagon grid shield
             let cx = this.x + this.w/2;
             let cy = this.y + this.h/2;
             let hexRadius = 40;
             let hexSize = 8;

             ctx.globalAlpha = 0.6;
             ctx.fillStyle = "#34c759";

             // Draw multiple hexagons in a grid pattern
             for(let row = -1; row <= 1; row++) {
                 for(let col = -1; col <= 1; col++) {
                     if (Math.abs(row) + Math.abs(col) > 2) continue;
                     let hx = cx + col * hexSize * 1.5;
                     let hy = cy + row * hexSize * Math.sqrt(3);

                     ctx.beginPath();
                     for(let i=0; i<6; i++) {
                         let angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                         let px = hx + Math.cos(angle) * hexSize;
                         let py = hy + Math.sin(angle) * hexSize;
                         if (i === 0) ctx.moveTo(px, py);
                         else ctx.lineTo(px, py);
                     }
                     ctx.closePath();
                     ctx.stroke();
                 }
             }

             ctx.globalAlpha = 1.0;
             ctx.restore();
         }

         if (this.doubleDamageTimer > 0) {
             ctx.save();
             ctx.strokeStyle = "#af52de";
             ctx.lineWidth = 2;
             ctx.setLineDash([5, 5]);
             ctx.strokeRect(this.x-2, this.y-2, this.w+4, this.h+4);
             ctx.restore();
         }
         
         // Paladin Shield Visual
         if (this.reflecting > 0) {
             ctx.save();
             let centerX = this.x + this.w/2;
             let centerY = this.y + this.h/2;
             let shieldAngle = this.dir === 1 ? 0 : Math.PI;
             
             ctx.beginPath();
             ctx.arc(centerX, centerY, 40, shieldAngle - Math.PI/3, shieldAngle + Math.PI/3);
             ctx.lineWidth = 4;
             ctx.strokeStyle = "#ffd60a";
             ctx.stroke();
             ctx.globalAlpha = 0.3;
             ctx.fillStyle = "#ffd60a";
             ctx.fill();
             ctx.restore();
         }
         
         // Gambler Roulette Animation
         if (this.rouletteAnim > 0) {
             this.rouletteAnim--;
             ctx.save();
             ctx.fillStyle = `hsl(${this.rouletteAnim * 20}, 100%, 50%)`;
             ctx.font = "bold 20px Arial";
             ctx.fillText("?", this.x + this.w/2, this.y - 20);
             ctx.restore();
         }

         if (this.atkAnimTimer > 0) {
            ctx.save();
            let cx = this.x + this.w/2; let cy = this.y + this.h/2; let range = 40;
            if (this.charKey === 'warrior') {
                // Enhanced crescent moon slash with trail
                ctx.beginPath();
                let startAngle = this.dir === 1 ? -0.5 : Math.PI - 0.5;
                let endAngle = this.dir === 1 ? 0.5 : Math.PI + 0.5;
                ctx.arc(cx, cy, range + 10, startAngle, endAngle, false);
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.atkAnimTimer/15})`;
                ctx.lineWidth = 8; ctx.stroke();
                ctx.strokeStyle = `rgba(255, 59, 48, ${this.atkAnimTimer/15})`;
                ctx.lineWidth = 4; ctx.stroke();

                // Add slash trail
                for(let i=0; i<3; i++) {
                    let trailAlpha = (this.atkAnimTimer/15) * (1 - i * 0.3);
                    ctx.beginPath();
                    ctx.arc(cx - this.dir * i * 5, cy, range + 10 - i * 3, startAngle, endAngle, false);
                    ctx.strokeStyle = `rgba(255, 59, 48, ${trailAlpha * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            } else if (this.charKey === 'tank') {
                ctx.fillStyle = `rgba(52, 199, 89, ${this.atkAnimTimer/15})`;
                let bx = this.dir === 1 ? this.x + this.w : this.x - 40;
                ctx.fillRect(bx, this.y, 40, this.h);
            } else if (this.charKey === 'ghost') {
                ctx.strokeStyle = `rgba(175, 82, 222, ${this.atkAnimTimer/15})`;
                ctx.lineWidth = 3;
                let offX = this.dir * 40;
                ctx.beginPath(); ctx.moveTo(cx, cy-10); ctx.lineTo(cx+offX, cy+10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+offX, cy+20); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, cy+10); ctx.lineTo(cx+offX, cy+30); ctx.stroke();
            } else if (this.charKey === 'paladin') {
                ctx.beginPath();
                ctx.arc(cx, cy, range + 20 - this.atkAnimTimer, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(255, 214, 10, ${this.atkAnimTimer/15})`;
                ctx.lineWidth = 5;
                ctx.stroke();
            }
            ctx.restore();
         }

         ctx.fillStyle = this.stats.color;
         if (this.invuln > 0 && Math.floor(Date.now()/50)%2===0) ctx.fillStyle = "#fff"; 
         ctx.fillRect(this.x, this.y, this.w, this.h);
         
         ctx.fillStyle = "rgba(255,255,255,0.6)";
         ctx.beginPath();
         if (this.dir === 1) { 
             ctx.moveTo(this.x + this.w - 4, this.y + 10);
             ctx.lineTo(this.x + this.w + 4, this.y + 15);
             ctx.lineTo(this.x + this.w - 4, this.y + 20);
         } else { 
             ctx.moveTo(this.x + 4, this.y + 10);
             ctx.lineTo(this.x - 4, this.y + 15);
             ctx.lineTo(this.x + 4, this.y + 20);
         }
         ctx.fill();
         
         ctx.font = "30px Apple Color Emoji, Segoe UI Emoji";
         ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "#fff";
         ctx.fillText(this.stats.icon, this.x + this.w/2, this.y + this.h/2 + 2);

         if (this.charging) {
             ctx.fillStyle = "#5ac8fa";
             ctx.fillRect(this.x, this.y - 10, this.w * (this.chargeTimer/60), 5);
         }
         if (this.mageChargingAtk) {
             ctx.fillStyle = "#5ac8fa";
             ctx.fillRect(this.x, this.y - 15, this.w * Math.min(1, this.mageChargeAtkTimer/120), 3);
         }
         ctx.globalAlpha = 1.0;
    }
}

class Projectile {
    constructor(x, y, vx, vy, ownerId, dmg, type) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.ownerId = ownerId; this.dmg = dmg; this.type = type;
        this.active = true;
        this.w = (type === 'fireball') ? 15 : 8; this.h = (type === 'fireball') ? 15 : 8;
        if (type === 'hook') { this.w = 20; this.h = 10; }
        if (type === 'card') {
            this.w = 14; this.h = 20;
            // Assign random suit and fixed height based on suit
            const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
            this.suit = suits[Math.floor(Math.random() * 4)];
            this.suitColor = (this.suit === 'â™¥' || this.suit === 'â™¦') ? 'red' : 'black';
            // Fixed heights for each suit (example values)
            const heights = { 'â™ ': 0, 'â™¥': -50, 'â™£': -100, 'â™¦': -150 };
            this.vy = 0; // Override any y velocity
        }
        if (type === 'dice_boulder') { this.w = 30; this.h = 30; }
        if (type === 'grenade') { this.w = 12; this.h = 12; }
        if (type === 'c4_trap') { this.w = 20; this.h = 6; }
        if (type === 'carpet_bomb') { this.w = 60; this.h = 60; this.x -= 30; } // Center alignment helper
        if (type === 'illusion_beam') {
            this.w = 40; this.h = 6;
            // Random color: red, yellow, blue, green
            const colors = ['#ff0000', '#ffff00', '#0000ff', '#00ff00'];
            this.beamColor = colors[Math.floor(Math.random() * 4)];
        }
        if (type === 'swap_bullet') { this.w = 20; this.h = 20; }
        if (type === 'light_pillar') { this.w = 60; this.h = CANVAS_H; this.y = 0; }
        if (type === 'time_needle') { this.w = 30; this.h = 6; }
        if (type === 'stasis_field') { this.w = 120; this.h = 120; this.life = 300; } // 5s

        if (type === 'laser_beam' || type === 'mage_ult') { this.w = CANVAS_W; this.h = 40; this.x = 0; this.life = 180; this.tickTimer = 0; }
        
        this.hasRooted = false; 
        this.age = 0; // For time needle sine wave
        
        // C4 & Bomb Logic
        if (type === 'c4_trap') this.life = 600; // 10 seconds
        if (type === 'carpet_bomb') this.hasExploded = false;
        if (type === 'light_pillar') { this.life = 90; this.tickTimer = 0; } // 1.5s duration
    }
    update() {
        if (!this.active) return;
        
        this.age++;

        // --- CHRONOMANCER ---
        if (this.type === 'time_needle') {
            // Sine wave velocity
            // Base speed 10, varying by +/- 5
            this.x += (this.vx > 0 ? 1 : -1) * (8 + Math.sin(this.age * 0.2) * 6);
            this.y += this.vy; // Usually 0
            
            // Check bounds
            if (this.x < -50 || this.x > CANVAS_W + 50) this.active = false;
        }
        else if (this.type === 'stasis_field') {
            this.life--;
            if (this.life <= 0) this.active = false;
            
            this.x += this.vx; 
            // Bounds check
            if(this.x < 0 || this.x > CANVAS_W - this.w) this.vx *= -1; // Bounce walls? or just stop. Let's bounce slowly.
            
            // Effect: Slow all OTHER projectiles in range
            let cx = this.x + this.w/2; 
            let cy = this.y + this.h/2;
            let r = this.w/2;
            
            projectiles.forEach(p => {
                if (p === this || !p.active || p.type === 'light_pillar' || p.type === 'laser_beam' || p.type === 'mage_ult') return;
                
                let pcx = p.x + p.w/2;
                let pcy = p.y + p.h/2;
                let dist = Math.sqrt(Math.pow(pcx - cx, 2) + Math.pow(pcy - cy, 2));
                
                if (dist < r) {
                    // Apply slow
                    p.x -= p.vx * 0.9; // Revert 90% of movement? No, simpler:
                    // We can't easily modify 'vx' permanently because projectiles might re-accelerate or rely on const vx.
                    // Instead, we manually move them BACK by 90% of their velocity effectively slowing them down for this frame.
                    // Since update() added vx, we subtract 0.9 * vx.
                    if (p.type !== 'time_needle') { // Time needle handles its own x calc
                        p.x -= p.vx * 0.9;
                        p.y -= p.vy * 0.9;
                    }
                }
            });
            return; // No damage by itself, just field
        }
        // --- PALADIN LOGIC (LIGHT PILLAR) ---
        else if (this.type === 'light_pillar') {
            this.life--;
            if (this.life <= 0) this.active = false;
            
            // Damage tick
            this.tickTimer++;
            if (this.tickTimer % 30 === 0) { // Every 0.5s
                let enemy = this.ownerId === 1 ? players[1] : players[0];
                if (enemy.x + enemy.w > this.x && enemy.x < this.x + this.w) {
                    enemy.takeDamage(this.dmg);
                    enemy.stunned = 60;
                    createPopup(enemy.x, enemy.y, "PURGED!", "#ffd60a");
                }
            }
            // Particles
            if (Settings.flashyMode) {
                for(let i=0; i<3; i++) {
                    let py = Math.random() * CANVAS_H;
                    particles.push(new Particle(this.x + Math.random()*this.w, py, "#fff", "aura"));
                }
            }
            return;
        }

        // --- DEMOLITIONIST PROJECTILES ---
        else if (this.type === 'grenade') {
            this.vy += 0.5; // Gravity
            this.x += this.vx;
            this.y += this.vy;
            
            // Bounds
            if (this.x < 0 || this.x > CANVAS_W) this.active = false;

            // Ground Collision
            let hitGround = false;
            if (this.y + this.h >= 650) { hitGround = true; }
            platforms.forEach(p => {
                if (this.vy > 0 && this.y + this.h >= p.y && this.y < p.y + 10 && this.x > p.x && this.x < p.x + p.w) hitGround = true;
            });
            
            // Enemy Hit Check
            let enemy = this.ownerId === 1 ? players[1] : players[0];
            // Paladin Reflection Check for Grenade
            if (enemy.charKey === 'paladin' && enemy.reflecting > 0) {
                // Basic distance check for collision before precise rect
                let close = (this.x < enemy.x + enemy.w + 20 && this.x + this.w > enemy.x - 20 && this.y < enemy.y + enemy.h && this.y + this.h > enemy.y);
                if (close) {
                    this.vx *= -1;
                    this.vy *= -1;
                    this.ownerId = enemy.id;
                    this.x += this.vx * 3; // Push out
                    createPopup(this.x, this.y, "REFLECT!", "#ffd60a");
                    soundManager.play('hit', 1.5); // Ping sound
                    return; // Skip normal hit
                }
            }

            let hitEnemy = (this.x < enemy.x + enemy.w && this.x + this.w > enemy.x && this.y < enemy.y + enemy.h && this.y + this.h > enemy.y);

            if (hitGround || hitEnemy) {
                this.active = false;
                spawnFlashyParticles(this.x, this.y, "#ff9500", "nova"); // Explosion
                spawnFlashyParticles(this.x, this.y, "#000", "splash"); // Smoke
                soundManager.play('hit', 0.5); // Low pitch bang
                if (hitEnemy) {
                    enemy.takeDamage(this.dmg);
                } else {
                    // Splash damage check if hitting ground near enemy
                    let dist = Math.sqrt(Math.pow((enemy.x+enemy.w/2) - this.x, 2) + Math.pow((enemy.y+enemy.h/2) - this.y, 2));
                    if (dist < 60) enemy.takeDamage(this.dmg);
                }
            }
            return;
        }

        else if (this.type === 'c4_trap') {
            this.life--;
            // Auto-explode after 10 seconds (600 frames)
            if (this.life >= 600) this.life = 0;
            // No movement
            if (this.life <= 0) {
                this.active = false;
                spawnFlashyParticles(this.x, this.y, "#ff9500", "nova");
                soundManager.play('hit', 0.6);
                // Area Damage
                let enemy = this.ownerId === 1 ? players[1] : players[0];
                let dist = Math.sqrt(Math.pow((enemy.x+enemy.w/2) - this.x, 2) + Math.pow((enemy.y+enemy.h/2) - this.y, 2));
                if (dist < 80) {
                    enemy.takeDamage(this.dmg);
                    createPopup(enemy.x, enemy.y, "BOOM!", "#ff3b30");
                }
            }
            return;
        }

        else if (this.type === 'carpet_bomb') {
            if (this.tickTimer > 0) {
                this.tickTimer--; // Waiting phase
                return;
            }

            this.life--;
            // Falling animation
            if (this.y < this.targetY) {
                this.y += this.vy;
            } else {
                this.y = this.targetY;
            }

            // Warning phase (first 60 frames)
            if (this.life > 60) {
                // Do nothing, just draw warning
            }
            // Explosion phase
            else if (this.life === 60) {
                 // BOOM
                 this.hasExploded = true;
                 spawnFlashyParticles(this.x + this.w/2, 650, "#ff9500", "nova");
                 spawnFlashyParticles(this.x + this.w/2, 650, "#ff0000", "death");
                 soundManager.play('ult', 0.5);

                 let enemy = this.ownerId === 1 ? players[1] : players[0];
                 // Check X range infinite Y (or high Y)
                 if (enemy.x + enemy.w > this.x && enemy.x < this.x + this.w && enemy.y + enemy.h > 500) {
                     enemy.takeDamage(this.dmg);
                     enemy.stunned = 30;
                 }
            }
            if (this.life <= 0) this.active = false;
            return;
        }
        
        // --- EXISTING PROJECTILE LOGIC ---

        // DICE PHYSICS
        else if (this.type === 'dice_boulder') {
            this.vy += 0.5; // Gravity
            this.x += this.vx;
            this.y += this.vy;
            
            // Bounce Check
            if (this.y + this.h > 650) { // Ground
                this.y = 650 - this.h;
                this.vy = -this.vy * 0.6;
                if(Math.abs(this.vy) < 1) this.active = false; // Stop eventually
            }
             platforms.forEach(p => {
                if (this.vy > 0 && this.y + this.h >= p.y && this.y < p.y + 10 && this.x > p.x && this.x < p.x + p.w) {
                    this.y = p.y - this.h;
                    this.vy = -this.vy * 0.6; 
                }
            });

            if (this.x < 0 || this.x > CANVAS_W) this.vx *= -1; // Bounce walls
        } 
        else if (this.type === 'laser_beam' || this.type === 'mage_ult') {
            this.life--; if (this.life <= 0) this.active = false;
            if (Math.random() < 0.5) {
                let py = this.y + (Math.random()-0.5)*20;
                particles.push(new Particle(Math.random()*CANVAS_W, py, "#5ac8fa", 'spark'));
            }
            this.tickTimer++;
            if (this.tickTimer % 30 === 0) {
                let enemy = this.ownerId === 1 ? players[1] : players[0];
                if (Math.abs((enemy.y + enemy.h/2) - this.y) < this.h) {
                     if (this.type === 'mage_ult') {
                         if (!this.hasRooted) {
                             enemy.takeDamage(1); 
                             enemy.stunned = 120; 
                             createPopup(enemy.x, enemy.y, "ROOTED!", "#5ac8fa");
                             this.hasRooted = true;
                         }
                     } else {
                        enemy.takeDamage(1);
                     }
                }
            }
            return;
        } else {
            // Normal movement
            this.x += this.vx; this.y += this.vy;
        }

        if (this.x < -50 || this.x > CANVAS_W + 50) this.active = false;
        
        if (Settings.flashyMode && Math.random() < 0.3) {
             particles.push(new Particle(this.x, this.y, this.ownerId===1?'#ff3b30':'#007aff', 'spark'));
        }

        let enemy = this.ownerId === 1 ? players[1] : players[0];
        
        // --- PALADIN REFLECTION CHECK (Universal) ---
        if (enemy.charKey === 'paladin' && enemy.reflecting > 0) {
            // Check collision with shield/body
            if (this.x < enemy.x + enemy.w + 20 && this.x + this.w > enemy.x - 20 && this.y < enemy.y + enemy.h && this.y + this.h > enemy.y) {
                // Check if reflective type
                if (['fireball', 'bullet', 'card', 'dice_boulder', 'illusion_beam', 'swap_bullet', 'time_needle'].includes(this.type)) {
                    this.vx *= -1;
                    this.vy *= -1;
                    this.ownerId = enemy.id; // Swap ownership
                    this.x += this.vx * 2; // Push away to avoid immediate re-collision
                    createPopup(this.x, this.y, "REFLECT!", "#ffd60a");
                    spawnFlashyParticles(this.x, this.y, "#ffd60a", "spark");
                    soundManager.play('hit', 2.0); // Ping
                    return; // Do not process hit logic below
                }
            }
        }

        if (this.x < enemy.x + enemy.w && this.x + this.w > enemy.x && this.y < enemy.y + enemy.h && this.y + this.h > enemy.y) {
            if (this.type === 'hook') {
                let owner = players[this.ownerId-1];
                owner.doubleDamageTimer = 120; 
                createPopup(owner.x, owner.y - 30, "Buffed!", "#af52de");
                enemy.x = owner.x + (owner.dir * 50);
                enemy.y = owner.y; 
                enemy.vx = 0; 
                enemy.stunned = 90; 
                createPopup(enemy.x, enemy.y, "HOOKED!", "#af52de");
                this.active = false;
            } 
            // --- Illusionist Swap Bullet ---
            else if (this.type === 'swap_bullet') {
                let owner = players[this.ownerId - 1];
                // Swap Logic: Teleport enemy to owner's front ground
                let targetX = owner.x + (owner.dir * 100);
                if (targetX < 0) targetX = 50; if(targetX > CANVAS_W) targetX = CANVAS_W - 50;
                
                enemy.x = targetX;
                enemy.y = 600; // Force to ground level (simple)
                enemy.vx = 0; enemy.vy = 0;
                enemy.stunned = 60;
                
                // FX
                spawnFlashyParticles(enemy.x, enemy.y, "#af52de", "nova");
                createPopup(enemy.x, enemy.y - 40, "TELEPORTED!", "#af52de");
                this.active = false;
            }
            else if (this.type === 'illusion_beam') {
                enemy.takeDamage(this.dmg);
                // Glass shatter effect
                for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, "#00ffff", "spark"));
                this.active = false;
            }
            else {
                // Add hit effects for mage fireball
                if (this.type === 'fireball') {
                    // Cyan and purple ripple effects
                    for(let i=0; i<3; i++) {
                        setTimeout(() => {
                            for(let j=0; j<8; j++) {
                                let angle = (j / 8) * Math.PI * 2;
                                let speed = 2 + i;
                                let p = new Particle(this.x, this.y, i % 2 === 0 ? "#00ffff" : "#af52de", 'ripple');
                                p.vx = Math.cos(angle) * speed;
                                p.vy = Math.sin(angle) * speed;
                                p.life = 20;
                                particles.push(p);
                            }
                        }, i * 50);
                    }
                }
                // Add hit sparks for marksman bullet
                if (this.type === 'bullet') {
                    for(let i=0; i<12; i++) {
                        let angle = Math.random() * Math.PI * 2;
                        let speed = 5 + Math.random() * 5;
                        let p = new Particle(this.x, this.y, "#ffcc00", 'spark_line');
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed;
                        p.life = 8;
                        p.size = 1;
                        particles.push(p);
                    }
                }
                enemy.takeDamage(this.dmg);
                this.active = false;
            }
        }
    }
    draw(ctx) {
        if (!this.active) return;
        if (this.tickTimer > 0 && this.type === 'carpet_bomb') return; // Don't draw if waiting

        // CHRONOMANCER STASIS FIELD
        if (this.type === 'stasis_field') {
            ctx.save();
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = "#5e5ce6";
            ctx.beginPath(); ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2 * 1.5, 0, Math.PI*2); ctx.fill();
            
            // Grid Effect
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            for(let i=0; i<this.w; i+=20) {
                ctx.moveTo(this.x + i, this.y); ctx.lineTo(this.x + i, this.y + this.h);
                ctx.moveTo(this.x, this.y + i); ctx.lineTo(this.x + this.w, this.y + i);
            }
            ctx.stroke();
            
            // Distortion (simple lines)
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = "#a0a0ff";
            ctx.beginPath();
            let offset = (globalTime * 2) % 20;
            ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2 - offset, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
            return;
        }
        
        // CHRONOMANCER TIME NEEDLE
        if (this.type === 'time_needle') {
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);
            // Rotation based on direction and time
            let rot = (this.vx > 0 ? 0 : Math.PI) + (Math.sin(this.age * 0.2) * 0.2); 
            ctx.rotate(rot);
            
            // Draw Needle
            ctx.fillStyle = "#5e5ce6";
            ctx.beginPath();
            ctx.moveTo(15, 0); ctx.lineTo(-15, -5); ctx.lineTo(-15, 5); ctx.fill();
            
            // Ghost trail
            ctx.strokeStyle = "rgba(94, 92, 230, 0.5)";
            ctx.beginPath();
            ctx.moveTo(-5, 0); ctx.lineTo(-25, 0); ctx.stroke();
            
            ctx.restore();
            return;
        }

        // PALADIN LIGHT PILLAR
        if (this.type === 'light_pillar') {
            ctx.save();
            // Outer glow
            let alpha = (this.life < 15) ? this.life/15 : 1; // Fade out
            ctx.globalAlpha = alpha * 0.6;
            ctx.fillStyle = "#ffd60a";
            ctx.fillRect(this.x - 10, 0, this.w + 20, CANVAS_H);
            
            // Inner Core
            ctx.globalAlpha = alpha;
            ctx.fillStyle = "#fff";
            ctx.fillRect(this.x, 0, this.w, CANVAS_H);
            
            // Particles rising effect (simulated with lines)
            ctx.strokeStyle = "#ffd60a";
            ctx.lineWidth = 2;
            let offset = (globalTime * 10) % 50;
            for(let i=0; i<CANVAS_H; i+=50) {
                ctx.beginPath();
                ctx.moveTo(this.x + Math.random()*this.w, i - offset);
                ctx.lineTo(this.x + Math.random()*this.w, i - offset - 20);
                ctx.stroke();
            }
            ctx.restore();
            return;
        }

        if (this.type === 'laser_beam' || this.type === 'mage_ult') {
            ctx.save();
            if (Settings.flashyMode) {
                ctx.shadowBlur = 20; ctx.shadowColor = "#5ac8fa";
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life/180})`;
                ctx.fillRect(0, this.y - this.h/2 + 10, CANVAS_W, this.h - 20);
            }

            // Main laser
            ctx.fillStyle = `rgba(90, 200, 250, ${this.life/180 * 0.5})`;
            ctx.fillRect(0, this.y - this.h/2, CANVAS_W, this.h);

            // Add flowing water wave effect
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.life/180 * 0.7})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            let waveOffset = (globalTime * 5) % 40;
            for (let x = -waveOffset; x < CANVAS_W; x += 40) {
                let waveY = this.y + Math.sin((x + globalTime * 2) * 0.1) * 8;
                if (x === -waveOffset) ctx.moveTo(x, waveY);
                else ctx.lineTo(x, waveY);
            }
            ctx.stroke();

            ctx.restore();
            return;
        }
        if (this.type === 'hook') {
            let owner = players[this.ownerId - 1];
            // Draw chain-like connection
            ctx.strokeStyle = "#8e8e93"; ctx.lineWidth = 3;
            let segments = 10;
            let dx = this.x - (owner.x + owner.w/2);
            let dy = this.y - (owner.y + owner.h/2);

            ctx.beginPath();
            for(let i=0; i<=segments; i++) {
                let t = i / segments;
                let x = (owner.x + owner.w/2) + dx * t;
                let y = (owner.y + owner.h/2) + dy * t;
                // Draw chain links (small ellipses)
                if (i % 2 === 0) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(Math.atan2(dy, dx));
                    ctx.fillStyle = "#666";
                    ctx.fillRect(-3, -2, 6, 4);
                    ctx.restore();
                }
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.fillStyle = "#af52de";
        } else if (this.type === 'card') {
            // Draw Card
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);
            ctx.rotate(globalTime * 0.2);
            ctx.fillStyle = "#fff";
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            ctx.strokeStyle = "#000";
            ctx.strokeRect(-this.w/2, -this.h/2, this.w, this.h);
            // Suit (use stored suit)
            ctx.fillStyle = this.suitColor;
            ctx.font = "12px Arial";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(this.suit, 0, 0);
            ctx.restore();
            return;
        } else if (this.type === 'dice_boulder') {
             // Draw Dice
             ctx.save();
             ctx.translate(this.x + this.w/2, this.y + this.h/2);
             ctx.rotate(globalTime * 0.1);
             ctx.fillStyle = "#fff";
             ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
             ctx.lineWidth = 2;
             ctx.strokeStyle = "#d4af37";
             ctx.strokeRect(-this.w/2, -this.h/2, this.w, this.h);
             // Dots (Simple representation)
             ctx.fillStyle = "#000";
             ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
             ctx.restore();
             return;
        }
        else if (this.type === 'grenade') {
            ctx.fillStyle = "#355e3b"; // Dark Green
            ctx.beginPath(); ctx.arc(this.x, this.y, this.w/2, 0, Math.PI*2); ctx.fill();
            // Blinking light
            if (Math.floor(globalTime / 10) % 2 === 0) {
                ctx.fillStyle = "#ff0000";
                ctx.beginPath(); ctx.arc(this.x + 2, this.y - 2, 2, 0, Math.PI*2); ctx.fill();
            }
            return;
        }
        else if (this.type === 'c4_trap') {
             ctx.fillStyle = "#444";
             ctx.fillRect(this.x, this.y, this.w, this.h);
             // Blinking countdown light
             ctx.fillStyle = (this.life % 20 < 10) ? "#ff0000" : "#330000";
             ctx.fillRect(this.x + 5, this.y + 1, 4, 4);
             // Digits
             ctx.fillStyle = "#fff";
             ctx.font = "8px Arial";
             ctx.fillText(Math.ceil(this.life/60), this.x + 15, this.y + 6);
             return;
        }
        else if (this.type === 'carpet_bomb') {
             if (this.hasExploded) return; // Handled by particles
             // Warning Circle on ground
             let alpha = (this.life % 10) / 10;
             ctx.fillStyle = `rgba(255, 0, 0, ${0.2 + alpha * 0.3})`;
             ctx.beginPath();
             ctx.ellipse(this.x + this.w/2, 650, this.w/2, 10, 0, 0, Math.PI*2);
             ctx.fill();
             ctx.strokeStyle = `rgba(255, 0, 0, ${0.8})`;
             ctx.stroke();

             // Falling Bomb Entity (visible throughout fall)
             if (this.y < 650) {
                 ctx.save();
                 ctx.fillStyle = "#000";
                 ctx.beginPath();
                 ctx.arc(this.x + this.w/2, this.y, 15, 0, Math.PI*2);
                 ctx.fill();
                 // Add flame trail
                 ctx.fillStyle = "#ff9500";
                 ctx.beginPath();
                 ctx.arc(this.x + this.w/2, this.y - 10, 8, 0, Math.PI*2);
                 ctx.fill();
                 ctx.restore();
             }
             return;
        }
        else if (this.type === 'illusion_beam') {
            // Use stored random color
            ctx.fillStyle = this.beamColor;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            // Glow
            if (Settings.flashyMode) {
                ctx.shadowColor = this.beamColor;
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.shadowBlur = 0;
            }
            return;
        }
        else if (this.type === 'swap_bullet') {
            ctx.save();
            // Pulsing Purple Orb
            let scale = 1 + Math.sin(globalTime * 0.2) * 0.1;
            ctx.translate(this.x, this.y);
            ctx.scale(scale, scale);
            ctx.fillStyle = "#af52de";
            ctx.beginPath(); ctx.arc(0, 0, this.w/2, 0, Math.PI*2); ctx.fill();
            
            // Inner White Core
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.arc(0, 0, this.w/4, 0, Math.PI*2); ctx.fill();
            ctx.restore();
            return;
        }
        else {
            // Enhanced Marksman Bullet
            if (this.type === 'bullet') {
                ctx.save();
                ctx.fillStyle = "#ffcc00";
                // Draw as elongated rectangle
                ctx.translate(this.x, this.y);
                let angle = Math.atan2(this.vy, this.vx);
                ctx.rotate(angle);
                ctx.fillRect(-8, -2, 16, 4); // Elongated
                // Highlight head
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(4, -1.5, 4, 3);
                ctx.restore();
                return;
            }

            // Enhanced Mage Fireball with rotating runes
            if (this.type === 'fireball') {
                ctx.save();
                // Draw rotating arcane runes
                let runeCount = 4;
                let runeRadius = this.w/2 + 5;
                let runeAngle = (globalTime * 0.1) % (Math.PI * 2);

                for (let i = 0; i < runeCount; i++) {
                    let angle = runeAngle + (i * Math.PI * 2 / runeCount);
                    let rx = this.x + Math.cos(angle) * runeRadius;
                    let ry = this.y + Math.sin(angle) * runeRadius;

                    ctx.fillStyle = "#5ac8fa";
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    // Draw small geometric shapes (triangles)
                    ctx.moveTo(rx, ry - 3);
                    ctx.lineTo(rx - 2.5, ry + 2);
                    ctx.lineTo(rx + 2.5, ry + 2);
                    ctx.closePath();
                    ctx.fill();
                }

                // Main fireball
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = this.ownerId === 1 ? '#ff3b30' : '#007aff';
                if(Settings.flashyMode) { ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle; }
                ctx.beginPath(); ctx.arc(this.x, this.y, this.w/2, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                return;
            }

            ctx.fillStyle = this.ownerId === 1 ? '#ff3b30' : '#007aff';
        }

        ctx.save();
        if(Settings.flashyMode) { ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle; }
        ctx.beginPath(); ctx.arc(this.x, this.y, this.w/2, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, type = 'normal') {
        this.x = x; this.y = y; this.type = type; this.color = color;
        this.vx = (Math.random() - 0.5) * 5; this.vy = (Math.random() - 0.5) * 5;
        this.life = 30; this.size = 4;
        
        if (type === 'splash') { this.vx *= 2; this.vy *= 2; this.life = 20; }
        else if (type === 'spark') { this.vx *= 0.5; this.vy *= 0.5; this.life = 15; this.size = 2; }
        else if (type === 'aura') { this.vx = 0; this.vy = -2; this.life = 20; this.size = 3; }
        else if (type === 'dash') { this.vx = -2; this.vy = 0; this.life = 10; this.size = 2; }
        else if (type === 'nova') { this.vx *= 4; this.vy *= 4; this.life = 50; this.size = 6; }
        else if (type === 'beam_trail') { this.vx = (Math.random()-0.5)*2; this.vy = (Math.random()-0.5)*2; this.life = 40; }
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life--;
        if (this.type === 'nova') this.size *= 0.95;
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        if(Settings.flashyMode && this.type === 'nova') ctx.globalCompositeOperation = 'lighter';
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }
}

function spawnFlashyParticles(x, y, color, type) {
    let count = type === 'nova' || type === 'death' ? 40 : 15;
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, type === 'death' ? 'nova' : type));
    }
}

function createPopup(x, y, text, color) { popups.push({x, y, text, color, life: 40}); }

function startGame() {
    if (!p1Char || !p2Char) return;
    Settings.load(); // Load and apply settings before start
    document.getElementById('start-screen').style.display = 'none';
    initMap();
    const p1 = new Player(1, p1Char, 100, 200);
    const p2 = new Player(2, p2Char, 900, 200);
    players = [p1, p2];
    // Removed manual setTarget call as GamepadHandler handles indices internally
    gameState = 'playing';
    spikeState = { active: false, timer: 0 };
    document.getElementById('p1-name').innerText = `P1: ${CHARACTERS[p1Char].icon} ${CHARACTERS[p1Char].name}`;
    document.getElementById('p2-name').innerText = `P2: ${CHARACTERS[p2Char].icon} ${CHARACTERS[p2Char].name}`;
    gameLoop();
}

function endGame(winnerId) {
    gameState = 'gameover';
    cancelAnimationFrame(gameLoopId);
    ctx.fillStyle = Settings.nightMode ? "rgba(0,0,0,0.85)" : "rgba(255,255,255,0.85)";
    ctx.fillRect(0,0, CANVAS_W, CANVAS_H);
    ctx.fillStyle = Settings.nightMode ? "#fff" : "#1d1d1f";
    ctx.font = "bold 60px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(`ç©å®¶ ${winnerId} è·èƒœ!`, CANVAS_W/2, CANVAS_H/2);
    setTimeout(() => { location.reload(); }, 3000);
}

function gameLoop(timestamp) {
    if (gameState === 'paused') {
        requestAnimationFrame(gameLoop); // Keep loop running for unpause
        return;
    }
    if (gameState !== 'playing') return;
    
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    spikeState.timer++;
    let cycle = spikeState.timer % 300; 
    spikeState.active = cycle < 180; 
    if (spikeState.timer % 60 === 0) globalTime++;

    gamepadHandler.update();

    ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

    platforms.forEach(p => {
        if (p.level === 1) ctx.fillStyle = spikeState.active ? "#ff3b30" : (Settings.nightMode ? "#333" : "#1d1d1f");
        else if (p.level === 2) ctx.fillStyle = "#4cd964";
        else if (p.level === 3) ctx.fillStyle = "#ff9500";
        else if (p.level === 4) ctx.fillStyle = "#007aff";
        
        if (Settings.flashyMode && p.level !== 1) {
            ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.beginPath(); ctx.roundRect(p.x, p.y, p.w, p.h, 5); ctx.fill();
        ctx.shadowBlur = 0;
        
        if (p.level === 1 && spikeState.active) {
            ctx.fillStyle = "#ff3b30";
            for(let i=p.x; i<p.x+p.w; i+=20) {
                ctx.beginPath(); ctx.moveTo(i, p.y); ctx.lineTo(i+10, p.y-15); ctx.lineTo(i+20, p.y); ctx.fill();
            }
            players.forEach(pl => {
                // GHOST IMMUNITY: If Invisible, ignore spikes
                if (pl.grounded && pl.platform === p && !pl.invisible) {
                    if (spikeState.timer % 60 === 0) pl.takeDamage(1, 'spike');
                }
            });
        }
    });
    
    ctx.fillStyle = Settings.nightMode ? "#86868b" : "#86868b";
    ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fillText("Level 2: Jump x1.5", 150, 525);
    ctx.fillText("Level 3: Slow", 50, 375);
    ctx.fillText("Level 4: Speed x2", 450, 225);

    players.forEach(p => { p.update(); p.draw(ctx); });
    projectiles = projectiles.filter(p => p.active);
    projectiles.forEach(p => { p.update(); p.draw(ctx); });
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => { p.update(); p.draw(ctx); });
    popups = popups.filter(p => p.life > 0);
    popups.forEach(p => {
        p.life--; p.y -= 0.5;
        ctx.fillStyle = p.color;
        ctx.font = "bold 16px -apple-system, BlinkMacSystemFont, sans-serif";
        ctx.fillText(p.text, p.x, p.y);
    });

    updateHUD();
    gameLoopId = requestAnimationFrame(gameLoop);
}

function updateHUD() {
    document.getElementById('game-timer').innerText = `Time: ${Math.floor(globalTime / 60)}:${(globalTime % 60).toString().padStart(2,'0')}`;
    if(Settings.nightMode) document.getElementById('game-timer').style.color = "#fff";
    
    players.forEach((p, i) => {
        let id = i + 1;
        document.getElementById(`p${id}-hp-text`).innerText = p.hp;
        document.getElementById(`p${id}-lives`).innerText = p.lives;
        let hpPct = (p.hp / p.maxHp) * 100;
        document.getElementById(`p${id}-hp-bar`).style.width = `${Math.max(0, hpPct)}%`;
        
        // Custom HUD Logic for Demolitionist (Integer Resource)
        let resPct = 0;
        if (p.charKey === 'demolitionist') {
            resPct = (p.resource / 3) * 100;
        } else {
            resPct = (p.resource / 100) * 100;
        }
        
        document.getElementById(`p${id}-res-bar`).style.width = `${resPct}%`;
        setCD(`p${id}-cd-atk`, p.cdAtk, 30);
        setCD(`p${id}-cd-skill`, p.cdSkill, 600); 
        
        let ultMax = (p.charKey === 'ghost') ? 600 : (p.charKey === 'demolitionist' ? 900 : (p.charKey === 'illusionist' ? 1200 : 1080));
        setCD(`p${id}-cd-ult`, p.cdUlt, ultMax);
        setCD(`p${id}-cd-swap`, p.cdSwap, 600);
    });
}

function setCD(elId, current, max) {
    let pct = Math.min(100, (current / (max || 100)) * 100);
    document.getElementById(elId).style.height = `${pct}%`;
}

initMap();
Settings.load(); // Init settings on load
menuLoop(); // Start polling for menu inputs
</script>
</body>
</html>